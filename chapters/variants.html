<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="sitemap" type="application/xml" href="/sitemap.xml">
  <title>Variants of PWS</title>
<link rel="stylesheet" href="../css/thesis-style.css" />
  <a href="../index.html" class="back-link">â† Back to Contents</a>
  <script src="../js/equation-tooltips.js"></script>
</head>
<body data-chapter="3">
<header id="title-block-header">
<h1 class="title">Variants of PWS</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#more-efficient-variants-of-pws"
id="toc-more-efficient-variants-of-pws">More Efficient Variants of
PWS</a>
<ul>
<li><a href="#marginalizing-in-trajectory-space"
id="toc-marginalizing-in-trajectory-space">Marginalizing in Trajectory
Space</a></li>
<li><a href="#rr-pws" id="toc-rr-pws">RR-PWS</a>
<ul>
<li><a href="#bootstrap-particle-filter"
id="toc-bootstrap-particle-filter">Bootstrap Particle Filter</a></li>
<li><a href="#intuitive-justification-of-the-algorithm"
id="toc-intuitive-justification-of-the-algorithm">Intuitive
Justification of the Algorithm</a></li>
<li><a href="#detailed-justification"
id="toc-detailed-justification">Detailed Justification</a></li>
<li><a href="#tuning-the-particle-filter"
id="toc-tuning-the-particle-filter">Tuning the Particle Filter</a></li>
</ul></li>
<li><a href="#ti-pws" id="toc-ti-pws">TI-PWS</a>
<ul>
<li><a href="#mcmc-sampling-in-trajectory-space"
id="toc-mcmc-sampling-in-trajectory-space">MCMC Sampling in Trajectory
Space</a></li>
</ul></li>
<li><a href="#sec:pws_variants_benchmark"
id="toc-sec:pws_variants_benchmark">Simple Application and
Benchmark</a></li>
<li><a href="#discussion" id="toc-discussion">Discussion</a></li>
<li><a href="#supplementary-information"
id="toc-supplementary-information">Supplementary Information</a>
<ul>
<li><a href="#gaussian-approximation-of-the-linear-system"
id="toc-gaussian-approximation-of-the-linear-system">Gaussian
Approximation of the Linear System </a></li>
</ul></li>
</ul></li>
<li><a href="#bibliography" id="toc-bibliography">References</a></li>
</ul>
</nav>
<blockquote>
<p>In the previous chapter, we introduced Path Weight Sampling (PWS), a
computational approach capable of providing exact information rate
estimates for any stochastic system. However, the direct implementation
of PWS becomes inefficient for complex systems and long trajectories due
to the high dimensionality of trajectory space. To overcome these
limitations, we present two improved PWS variants in this chapter,
inspired by free-energy estimation techniques from statistical physics.
First, Rosenbluth-Rosenbluth PWS (RR-PWS) leverages computational
strategies developed for polymer chemical potential calculations,
enhancing efficiency for sampling in trajectory spaces. Second,
Thermodynamic Integration PWS (TI-PWS) applies thermodynamic integration
combined with trajectory space MCMC sampling, inspired by transition
path sampling. We benchmark these methods using a simple coupled
birth-death model, comparing the effectiveness of all three PWS variants
against analytical results and the Gaussian approximation.</p>
</blockquote>
<h2 id="ch:variants" id="more-efficient-variants-of-pws">More Efficient
Variants of PWS</h2>
<p>To quantify information transmission, be it in a natural or
engineered information processing system, we need to be able to compute
the mutual information between input and output trajectories, from which
the information transmission rate can be obtained. However, because of
the high dimensionality of the trajectory space, computing the mutual
information between trajectories is exceedingly difficult, if not
impossible, because the conventional non-parametric binning approach to
estimate the required trajectory probability distributions cannot be
used. Indeed, except for very simple models, the mutual information
between trajectories is typically computed using approximations that are
often uncontrolled. In the previous chapter, we introduced a
computational scheme called Path Weight Sampling (PWS), which, for the
first time, makes it possible to compute the information rate exactly,
for any stochastic system.</p>
<p>Yet, the scheme presented in that chapter, Direct PWS, becomes
inefficient for more complex systems and longer trajectories. The reason
is that the number of possible trajectories increases exponentially with
trajectory length, leading to a corresponding increase in the variance
of the estimate. Hence, for long trajectories the PWS estimate may prove
to be computationally infeasible. To address this issue, we describe two
improved variants of PWS in this section, both based on free-energy
estimators from statistical physics.</p>
<p>Specifically, in <a href="#sec:smc">Sec. smc</a> we present
<em>Rosenbluth-Rosenbluth PWS</em> (RR-PWS) which exploits the
observation that the computation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
is analogous to the calculation of the (excess) chemical potential of a
polymer, for which efficient methods have been developed <span
class="citation"
data-cites="1990.Siepmann 1997.Grassberger 2002.Frenkel">Â [<a
href="#ref-1990.Siepmann" role="doc-biblioref">1</a>â€“<a
href="#ref-2002.Frenkel" role="doc-biblioref">3</a>]</span>. In <a
href="#sec:thermodynamic-integration">Sec.
thermodynamic-integration</a>, we present <em>Thermodynamic Integration
PWS</em> (TI-PWS) which is based on the classic free energy estimation
technique of thermodynamic integration <span class="citation"
data-cites="1984.Frenkel 1998.Gelman 2001.Neal">Â [<a
href="#ref-1984.Frenkel" role="doc-biblioref">4</a>â€“<a
href="#ref-2001.Neal" role="doc-biblioref">6</a>]</span> in conjunction
with a trajectory space MCMC sampler using ideas from transition path
sampling <span class="citation" data-cites="2002.Bolhuis">Â [<a
href="#ref-2002.Bolhuis" role="doc-biblioref">7</a>]</span>.</p>
<p>In <a href="#sec:pws_variants_benchmark">Sec.
pws_variants_benchmark</a> we apply PWS to a well-known model system. It
consists a simple pair of coupled birth-death processes which allows us
to test the efficiency of the three PWS variants, as well as to compare
the PWS results with analytical results from the Gaussian approximation
<span class="citation" data-cites="2009.Tostevin">Â [<a
href="#ref-2009.Tostevin" role="doc-biblioref">8</a>]</span> and the
technique by Duso and Zechner <span class="citation"
data-cites="2019.Duso">Â [<a href="#ref-2019.Duso"
role="doc-biblioref">9</a>]</span>.</p>
<h2 id="sec:marginalization"
id="marginalizing-in-trajectory-space">Marginalizing in Trajectory
Space</h2>
<p>PWS evaluates the mutual information
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’®</mi><mo>,</mo><mi>ğ’³</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">I(\mathcal{S},\mathcal{X})</annotation></semantics></math>
from the marginal entropy
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’³</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">H(\mathcal{X})</annotation></semantics></math>
and the conditional entropy
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’³</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’®</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">H(\mathcal{X}|\mathcal{S})</annotation></semantics></math>,
see <a
href="#eq:mutual_information_entropies">eq:mutual_information_entropies</a>.
Of these two entropies, the conditional one can be efficiently computed
using the scheme described in the previous chapter, and as used in DPWS.
However, obtaining the marginal entropy
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’³</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>âˆ’</mi><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">H(\mathcal{X}) = - \int \mathcal{D}[\mathbfit{x}]\ \mathcal{P}[\mathbfit{x}] \ln\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
is much more challenging. Indeed, the computationally most expensive
part of Direct PWS is the evaluation of the marginalization integral
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><msub><mi>ğ’™</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}_i]=\int\mathcal{D}[\mathbfit{s}] \mathcal{P}[\mathbfit{s},\mathbfit{x}_i]</annotation></semantics></math>
which needs to be performed for every sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’™</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>ğ’™</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">\mathbfit{x}_1,\ldots,\mathbfit{x}_N</annotation></semantics></math>.
Consequently, the computational efficiency of this marginalization is
essential for the overall performance.</p>
<p>Marginalization is a general term to denote an operation where one or
more variables are integrated out of a joint probability distribution.
For instance, we obtain the marginal probability distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s},\mathbfit{x}]</annotation></semantics></math>
by computing the integral </p>
<div id="eq:generic-marginalization">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}] = \int\mathcal{D}[\mathbfit{s}]\ \mathcal{P}[\mathbfit{s},\mathbfit{x}] = \int\mathcal{D}[\mathbfit{s}]\ \mathcal{P}[\mathbfit{s}]\mathcal{P}[\mathbfit{x}|\mathbfit{s}]\,.
    \label{eq:generic-marginalization}</annotation></semantics></math>
</div>
<p>In DPWS, we use <a href="#eq:marginal-naive">eq:marginal-naive</a> to
compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
which involves generating independent input trajectories from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>.
However, this this is not the optimal Monte Carlo technique to perform
the marginalization. The generated input trajectories are independent
from the output trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>.
Thus, we ignore the causal connection between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>,
and we typically end up sampling trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ’”</mi><mo>â‹†</mo></msup><annotation encoding="application/x-tex">\mathbfit{s}^\star</annotation></semantics></math>
whose likelihoods
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><msup><mi>ğ’”</mi><mo>â‹†</mo></msup><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}|\mathbfit{s}^\star]</annotation></semantics></math>
are very small. Then, most sampled trajectories have small integral
weights, and only very few samples provide a significant contribution to
the average. The variance of the result is then very large because the
effective sample size is much smaller than the total sample size. The
use of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>
as the sampling distribution is thus only practical in cases where the
dependence of the output on the input is not too strong. It follows that
this sampling scheme works best when the mutual information is not too
large <a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>This is a well known Monte Carlo sampling problem and a large number
of techniques have been developed to solve it. The two variants of our
scheme, RR-PWS and TI-PWS, both make use of ideas from statistical
physics for the efficient computation of free energies.</p>
<div id="tab:translation">
<table>
<caption>á¹®ranslation to the notation of statistical physics. The
definitions of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’°</mi><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ’°</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\mathcal{U}_0</annotation></semantics></math>
that are used here are given in <a href="#eq:h0">eq:h0</a> and <a
href="#eq:h1">eq:h1</a>.</caption>
<thead>
<tr>
<th
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s},\mathbfit{x}]</annotation></semantics></math></th>
<th
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>e</mi><mrow><mi>âˆ’</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup><annotation encoding="application/x-tex">e^{-\mathcal{U}[\mathbfit{s}, \mathbfit{x}]}</annotation></semantics></math></th>
</tr>
</thead>
<tbody>
<tr>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><msub><mi>ğ’µ</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></mfrac><msup><mi>e</mi><mrow><mi>âˆ’</mi><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\frac{1}{\mathcal{Z}_0[\mathbfit{x}]} e^{-\mathcal{U}_0[\mathbfit{s}]}</annotation></semantics></math></td>
</tr>
<tr>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}|\mathbfit{x}]</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>ğ’µ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></mfrac><msup><mi>e</mi><mrow><mi>âˆ’</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\frac{1}{\mathcal{Z}[\mathbfit{x}]} e^{-\mathcal{U}[\mathbfit{s}, \mathbfit{x}]}</annotation></semantics></math></td>
</tr>
<tr>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’µ</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{Z}_0[\mathbfit{x}]</annotation></semantics></math></td>
</tr>
<tr>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’µ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{Z}[\mathbfit{x}]</annotation></semantics></math></td>
</tr>
<tr>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}|\mathbfit{s}]</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>e</mi><mrow><mi>âˆ’</mi><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup><annotation encoding="application/x-tex">e^{-\Delta\mathcal{U}[\mathbfit{s}, \mathbfit{x}]}</annotation></semantics></math></td>
</tr>
</tbody>
</table>
</div>
<p>To understand how these ideas can be applied to compute the marginal
probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>,
it is helpful to rephrase the marginalization integral in <a
href="#eq:generic-marginalization">eq:generic-marginalization</a> in the
language of statistical physics. In this language,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
corresponds to the normalization constant, or partition function, of the
Boltzmann distribution for the potential<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
</p>
<div id="eq:h1">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>âˆ’</mi><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\label{eq:h1} \mathcal{U}[\mathbfit{s},\mathbfit{x}] = -\ln\mathcal{P}[\mathbfit{s},\mathbfit{x}] \,.</annotation></semantics></math>
</div>
<p> In <a href="#eq:h1">eq:h1</a>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
is interpreted as a variable in the configuration space, while
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>
acts as an auxiliary variable, i.e., a parameter. Note that both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>
still represent trajectories. For this potential, the partition function
is given by </p>
<div id="eq:partition-function">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’µ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.278em"></mspace><msup><mi>e</mi><mrow><mi>âˆ’</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathcal{Z}[\mathbfit{x}] = \int\mathcal{D}[\mathbfit{s}]\; e^{-\mathcal{U}[\mathbfit{s},\mathbfit{x}]} \,.
    \label{eq:partition-function}</annotation></semantics></math>
</div>
<p> The integral only runs over the configuration space, i.e. we
integrate only with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>.
By inserting the expression for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}[\mathbfit{s},\mathbfit{x}]</annotation></semantics></math>,
we see that the partition function is exactly equal to the marginal
probability of the output, i.e.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’µ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{Z}[\mathbfit{x}] = \mathcal{P}[\mathbfit{x}]</annotation></semantics></math>.
The free energy is given by </p>
<div id="eq:free-energy">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„±</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>âˆ’</mi><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mi>ğ’µ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>âˆ’</mi><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathcal{F}[\mathbfit{x}] = -\ln \mathcal{Z}[\mathbfit{x}] = -\ln \mathcal{P}[\mathbfit{x}]\,.
    \label{eq:free-energy}</annotation></semantics></math>
</div>
<p>In statistical physics it is well known that the free energy cannot
be directly measured from a simulation. Instead, one estimates the
free-energy difference </p>
<div id="eq:free-energy-difference">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î”</mi><mi>â„±</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>â„±</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>âˆ’</mo><msub><mi>â„±</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>âˆ’</mi><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mfrac><mrow><mi>ğ’µ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><mrow><msub><mi>ğ’µ</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\Delta\mathcal{F}[\mathbfit{x}] = \mathcal{F}[\mathbfit{x}] - \mathcal{F}_0[\mathbfit{x}] = -\ln \frac{\mathcal{Z}[\mathbfit{x}]}{\mathcal{Z}_0[\mathbfit{x}]}
    \label{eq:free-energy-difference}</annotation></semantics></math>
</div>
<p> between the system and a reference system with known free energy
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>â„±</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{F}_0[\mathbfit{x}]</annotation></semantics></math>.
The reference system can be freely chosen and is usually defined using a
Boltzmann distribution for a convenient reference potential
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}_0[\mathbfit{s}, \mathbfit{x}]</annotation></semantics></math>.
In our case, a natural choice of reference potential is </p>
<div id="eq:h0">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>âˆ’</mi><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\label{eq:h0} \mathcal{U}_0[\mathbfit{s},\mathbfit{x}]=-\ln\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>
</div>
<p> with the corresponding partition function being simply </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’µ</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mn>1</mn><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathcal{Z}_0[\mathbfit{x}]=\int\mathcal{D}[\mathbfit{s}]\ \mathcal{P}[\mathbfit{s}]=1\,.</annotation></semantics></math>
<p> The reference free energy therefore is zero
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>â„±</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>âˆ’</mi><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><msub><mi>ğ’µ</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathcal{F}_0[\mathbfit{x}]=-\ln\mathcal{Z}_0[\mathbfit{x}]=0</annotation></semantics></math>).
Hence, the free-energy difference is </p>
<div id="eq:free-energy-difference-equals-lnp">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î”</mi><mi>â„±</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>â„±</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>âˆ’</mi><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\Delta\mathcal{F}[\mathbfit{x}]= \mathcal{F}[\mathbfit{x}] = -\ln\mathcal{P}[\mathbfit{x}]\,.
    \label{eq:free-energy-difference-equals-lnp}</annotation></semantics></math>
</div>
<p>Note that in our case the reference potential
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>âˆ’</mi><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}_0[\mathbfit{s},\mathbfit{x}]=-\ln\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>
does not depend on the output trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>,
i.e.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>â‰¡</mo><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}_0[\mathbfit{s},\mathbfit{x}]\equiv\mathcal{U}_0[\mathbfit{s}]</annotation></semantics></math>.
It describes a <em>non-interacting</em> version of our input-output
system where the input trajectories evolve independently of the fixed
output trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>.</p>
<p>What is the interaction between the output
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>
and the input trajectory ensemble? We define the interaction potential
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\Delta\mathcal{U}[\mathbfit{s}, \mathbfit{x}]</annotation></semantics></math>
through </p>
<div id="eq:interaction-potential">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo>+</mo><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}[\mathbfit{s}, \mathbfit{x}] = \mathcal{U}_0[\mathbfit{s}] + \Delta\mathcal{U}[\mathbfit{s}, \mathbfit{x}] \,.
    \label{eq:interaction-potential}</annotation></semantics></math>
</div>
<p> The interaction potential makes it apparent that the distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
corresponding to the potential
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}[\mathbfit{s}, \mathbfit{x}]</annotation></semantics></math>
is biased by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>
with respect to the distribution corresponding to the reference
potential
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}_0[\mathbfit{s}]</annotation></semantics></math>.
By inserting the expressions for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}_0[\mathbfit{s}]</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}[\mathbfit{s}, \mathbfit{x}]</annotation></semantics></math>
into <a href="#eq:interaction-potential">eq:interaction-potential</a> we
see that </p>
<div id="eq:boltzmann-weight">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>âˆ’</mi><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>âˆ’</mi><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mi mathvariant="normal">P</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>s</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>âˆ’</mo><msubsup><mo>âˆ«</mo><mn>0</mn><mi>T</mi></msubsup><mi>d</mi><mi>t</mi><mspace width="0.222em"></mspace><msub><mi>â„’</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \Delta\mathcal{U}[\mathbfit{s}, \mathbfit{x}] &amp;= -\ln\mathcal{P}[\mathbfit{x}|\mathbfit{s}] \\
    &amp;= -\ln\mathrm{P}(x_0|s_0)-\int^T_0 dt\ \mathcal{L}_t[\mathbfit{s}, \mathbfit{x}]
\end{aligned}
\label{eq:boltzmann-weight}</annotation></semantics></math>
</div>
<p> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>â„’</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{L}_t[\mathbfit{s}, \mathbfit{x}]</annotation></semantics></math>
is given by <a href="#eq:log_traj_prob">eq:log_traj_prob</a> and can be
directly computed from the master equation. This expression illustrates
that the interaction of the output trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>
with the ensemble of input trajectories is characterized by the
trajectory likelihood
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}|\mathbfit{s}]</annotation></semantics></math>.</p>
<p>To summarize, in this section we have introduced notation (see <a
href="#tab:translation">tab:translation</a>) showing that computing a
marginalization integral is equivalent to the computation of a
free-energy difference. This picture allows us to distinguish between
two ensembles for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>,
the <em>non-interacting</em> ensemble distributed according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\exp(-\mathcal{U}_0[\mathbfit{s}])=\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>,
and the <em>interacting</em> ensemble distributed according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo><mo>âˆ</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\exp(-\mathcal{U}[\mathbfit{s},\mathbfit{x}])\propto\mathcal{P}[\mathbfit{s}|\mathbfit{x}]</annotation></semantics></math>.
With these notions we can rewrite the brute force estimate in Direct PWS
(<a href="#ch:dpws">Ch. dpws</a>) as </p>
<div id="eq:boltzmann-average">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mfrac><mrow><mi>ğ’µ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><mrow><msub><mi>ğ’µ</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></mfrac></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mo stretchy="false" form="prefix">âŸ¨</mo><msup><mi>e</mi><mrow><mi>âˆ’</mi><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup><msub><mo stretchy="false" form="postfix">âŸ©</mo><mn>0</mn></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
     \mathcal{P}[\mathbfit{x}] = \frac{\mathcal{Z}[\mathbfit{x}]}{\mathcal{Z}_0[\mathbfit{x}]} &amp;= \langle e^{-\Delta\mathcal{U}[\mathbfit{s}, \mathbfit{x}]} \rangle_0 
     \label{eq:boltzmann-average}
\end{aligned}</annotation></semantics></math>
</div>
<p> where the notation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">âŸ¨</mo><mi>â‹¯</mi><msub><mo stretchy="false" form="postfix">âŸ©</mo><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\langle\cdots\rangle_0</annotation></semantics></math>
refers to an average with respect to the non-interacting ensemble. By
inserting the expressions for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ’°</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\mathcal{U}_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi></mrow><annotation encoding="application/x-tex">\Delta\mathcal{U}</annotation></semantics></math>,
it is easy to verify that this estimate is equivalent to <a
href="#eq:marginal-naive">eq:marginal-naive</a>.</p>
<p>The more advanced variants of PWS introduced below leverage the
analogy with statistical physics to improve the efficiency of
marginalization. RR-PWS draws ideas from soft condensed matter
simulations by recognizing that <a
href="#eq:free-energy-difference">eq:free-energy-difference</a> has the
same form as the excess chemical potential of a polymer for which
efficient computation techniques have been developed <span
class="citation" data-cites="1990.Siepmann 1994.Mueller">Â [<a
href="#ref-1990.Siepmann" role="doc-biblioref">1</a>,<a
href="#ref-1994.Mueller" role="doc-biblioref">10</a>]</span>. Meanwhile,
TI-PWS is inspired by Transition Path Sampling (TPS) for sampling rare
trajectories <span class="citation" data-cites="2002.Bolhuis">Â [<a
href="#ref-2002.Bolhuis" role="doc-biblioref">7</a>]</span> and uses
thermodynamic integration for free-energy estimation.</p>
<h2 id="sec:smc" id="rr-pws">RR-PWS</h2>
<figure id="fig:smc">
<img src="../images/FigureSMC.svg"  />
<figcaption>Illustration of one step of the bootstrap particle filter in
RR-PWS. We start with a set of trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">\mathbfit{s}^k_{[0,i-1]}</annotation></semantics></math>
with time span
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msub><mi>Ï„</mi><mn>0</mn></msub><mo>,</mo><msub><mi>Ï„</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\tau_0,\tau_{i-1}]</annotation></semantics></math>
(left panel). In the next step we propagate these trajectories forward
in time to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\tau_i</annotation></semantics></math>,
according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>
(central panel). Then we resample the trajectories according to the
Boltzmann weights of their most recent segments, effectively eliminating
or duplicating individual segments. An example outcome of the resampling
step is shown in the right panel where the bottom trajectory was
duplicated and one of the top trajectories was eliminated. These steps
are repeated for each segment, until a set of input trajectories of the
desired length is generated. The intermediate resampling steps bias the
trajectory distribution from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>
towards
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}|\mathbfit{x}]</annotation></semantics></math>.
</figcaption>
</figure>
<p>In Rosenbluth-Rosenbluth PWS we compute the free-energy difference
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î”</mi><mi>â„±</mi></mrow><annotation encoding="application/x-tex">\Delta\mathcal{F}</annotation></semantics></math>
between the ideal system
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ’°</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\mathcal{U}_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’°</mi><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math>
in a <em>single</em> simulation just like in the brute force method.
However, instead of generating
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
trajectories in an uncorrelated fashion according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\exp(-\mathcal{U}_0[\mathbfit{s}])=\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>,
we bias our sampling distribution towards
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo><mo>âˆ</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\exp(-\mathcal{U}[\mathbfit{s}, \mathbfit{x}])\propto\mathcal{P}[\mathbfit{s}|\mathbfit{x}]</annotation></semantics></math>
to reduce the sampling problems found in DPWS.</p>
<p>The classical scheme for biasing the sampling distribution in polymer
physics is due to Rosenbluth and Rosenbluth <span class="citation"
data-cites="1955.Rosenbluth">Â [<a href="#ref-1955.Rosenbluth"
role="doc-biblioref">11</a>]</span> in their study of self-avoiding
chains. A substantial improvement of the Rosenbluth algorithm was
achieved by Grassberger, by generating polymers using pruning and
enrichment steps, thereby eliminating configurations that do not
significantly contribute to the average. This scheme is known as the
pruned-enriched Rosenbluth method, or PERM <span class="citation"
data-cites="1997.Grassberger">Â [<a href="#ref-1997.Grassberger"
role="doc-biblioref">2</a>]</span>. While PERM is much more powerful
than the standard Rosenbluth algorithm, its main drawback is that it
requires careful tuning of the pruning and enrichment schedule to
achieve optimal convergence. Therefore we have opted to use a technique
that is similar in spirit to PERM but requires less tuning, the
bootstrap particle filter <span class="citation"
data-cites="1993.Gordon">Â [<a href="#ref-1993.Gordon"
role="doc-biblioref">12</a>]</span>. We will describe how to use PWS
with a particle filter below. That said, we want to stress that the
particle filter can easily be replaced by PERM or other related methods
<span class="citation" data-cites="2004.Prellberg">Â [<a
href="#ref-2004.Prellberg" role="doc-biblioref">13</a>]</span>. Also
schemes inspired by variants of Forward Flux Sampling <span
class="citation" data-cites="2006.Allen 2012.Becker">Â [<a
href="#ref-2006.Allen" role="doc-biblioref">14</a>,<a
href="#ref-2012.Becker" role="doc-biblioref">15</a>]</span> could be
developed.</p>
<h3 id="bootstrap-particle-filter">Bootstrap Particle Filter</h3>
<p>In the methods discussed above, a polymer is grown monomer by
monomer. In a continuous-time Markov process this translates to
trajectories being grown segment by segment. To define the segments, we
choose a time discretization
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><msub><mi>Ï„</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>Ï„</mi><mn>2</mn></msub><mo>&lt;</mo><mi>â‹¯</mi><mo>&lt;</mo><msub><mi>Ï„</mi><mrow><mi>n</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><mo>&lt;</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">0&lt;\tau_1&lt;\tau_2&lt;\cdots&lt;\tau_{n-1}&lt;T</annotation></semantics></math>.
Thus, each trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
of duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
consists of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
segments where we denote the segment between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\tau_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\tau_j</annotation></semantics></math>
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><annotation encoding="application/x-tex">\mathbfit{s}_{[i,j]}</annotation></semantics></math>
(we define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï„</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\tau_0=0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï„</mi><mi>n</mi></msub><mo>=</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\tau_n=T</annotation></semantics></math>).
The particle filter uses the following procedure to grow an ensemble of
trajectories segment by segment:</p>
<ol>
<li><p>Generate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
starting points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>s</mi><mn>0</mn><mn>1</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>s</mi><mn>0</mn><mi>M</mi></msubsup></mrow><annotation encoding="application/x-tex">s^1_0, \ldots, s^M_0</annotation></semantics></math>
according to the initial condition of the input signal
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">P</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>s</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{P}(s_0)</annotation></semantics></math>.</p></li>
<li><p>Iterate for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,n</annotation></semantics></math>:</p>
<ol>
<li><p>Starting with an ensemble of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
partial trajectories of duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\tau_{i-1}</annotation></semantics></math>
(if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math>
an ensemble of starting points) which we label
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">\mathbfit{s}^k_{[0,i-1]}</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">k=1,\ldots,M</annotation></semantics></math>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mn>1</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mi>M</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">\left(\mathbfit{s}^1_{[0,i-1]}, \ldots, \mathbfit{s}^M_{[0,i-1]}\right)\,,</annotation></semantics></math>
propagate each trajectory (or each starting point) forward in time from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\tau_{i-1}</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\tau_{i}</annotation></semantics></math>.
Propagation is performed according to the natural dynamics of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>,
i.e. generating a new segment
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">\mathbfit{s}^k_{[i-1,i]}</annotation></semantics></math>
with probability
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">gen</mtext></msubsup><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>ğ’«</mi><mrow><mo stretchy="true" form="prefix">[</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><mo stretchy="false" form="prefix">|</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mi>e</mi><mrow><mi>âˆ’</mi><msub><mi>ğ’°</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">[</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">]</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">p^\text{gen}_i(k) = \mathcal{P}\left[\mathbfit{s}^k_{[i-1,i]}|\mathbfit{s}^k_{[0,i-1]}\right] = e^{-\mathcal{U}_0\left[\mathbfit{s}^k_{[i-1,i]}\right]}</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">k=1,\ldots,M</annotation></semantics></math>.</p></li>
<li><p>Compute the Boltzmann weight
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>U</mi><mi>i</mi><mi>k</mi></msubsup><mo>=</mo><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><mo>,</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">U^k_i = \Delta\mathcal{U}[\mathbfit{s}^k_{[i-1,i]},\mathbfit{x}_{[i-1,i]}]</annotation></semantics></math>
of each new segment. This Boltzmann weight of a segment from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\tau_{i-1}</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\tau_i</annotation></semantics></math>
can be expressed as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>U</mi><mi>i</mi><mi>k</mi></msubsup><mo>=</mo><mi>âˆ’</mi><msub><mi>Î´</mi><mrow><mn>1</mn><mi>i</mi></mrow></msub><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mi mathvariant="normal">P</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>s</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>âˆ’</mo><msubsup><mo>âˆ«</mo><msub><mi>Ï„</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><msub><mi>Ï„</mi><mi>i</mi></msub></msubsup><mi>d</mi><mi>t</mi><mspace width="0.222em"></mspace><msub><mi>â„’</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">[</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><mo>,</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">U^k_i =
        -\delta_{1i} \ln\mathrm{P}(x_0|s_0) -\int^{\tau_i}_{\tau_{i-1}} dt\ \mathcal{L}_t[\mathbfit{s}^k_{[i-1,i]}, \mathbfit{x}_{[i-1,i]}]\,,
        \label{eq:weight_segment}</annotation></semantics></math> see <a
href="#eq:boltzmann-weight">eq:boltzmann-weight</a>, and is therefore
straightforward to compute from the master equation.</p></li>
<li><p>Sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
times from the distribution
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mtext mathvariant="normal">select</mtext></msubsup><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><msup><mi>e</mi><mrow><mi>âˆ’</mi><msubsup><mi>U</mi><mi>i</mi><mi>k</mi></msubsup></mrow></msup><msub><mi>w</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">p^\text{select}_i(k) = \frac{e^{-U^k_i}}{w_i}
        \label{eq:index-prob}</annotation></semantics></math> where the
Rosenbluth weight
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math>
is defined as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><munderover><mo>âˆ‘</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msup><mi>e</mi><mrow><mi>âˆ’</mi><msubsup><mi>U</mi><mi>i</mi><mi>k</mi></msubsup></mrow></msup><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">w_i = \sum^M_{k=1} e^{-U^k_i}\,.</annotation></semantics></math>
This sampling procedure yields
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
randomly drawn indices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>â„“</mi><mi>i</mi><mn>1</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>â„“</mi><mi>i</mi><mi>M</mi></msubsup></mrow><annotation encoding="application/x-tex">\ell^1_i, \ldots, \ell^M_i</annotation></semantics></math>.
EÌ±ach
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>â„“</mi><mi>i</mi><mi>k</mi></msubsup><annotation encoding="application/x-tex">\ell^k_i</annotation></semantics></math>
is an index that lies in the range from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">1,\ldots,M</annotation></semantics></math>
and that points to one of the trajectories that have been generated up
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\tau_i</annotation></semantics></math>.
To continue the sampling procedure, we relabel the indices such that the
resampled set of trajectories is defined by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>ğ’”</mi><mo accent="true">Ìƒ</mo></mover><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><mo>â†</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><msubsup><mi>â„“</mi><mi>i</mi><mi>k</mi></msubsup></msubsup></mrow><annotation encoding="application/x-tex">\tilde{\mathbfit{s}}^k_{[0,i]} \gets \mathbfit{s}^{\ell^k_i}_{[0,i]}</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">k=1,\ldots,M</annotation></semantics></math>.
The list
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mover><mi>ğ’”</mi><mo accent="true">Ìƒ</mo></mover><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mn>1</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mover><mi>ğ’”</mi><mo accent="true">Ìƒ</mo></mover><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>M</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left( \tilde{\mathbfit{s}}^1_{[0,i]}, \ldots, \tilde{\mathbfit{s}}^M_{[0,i]} \right)</annotation></semantics></math>
is subsequently used as the input for the next iteration of the
algorithm.</p></li>
</ol></li>
</ol>
<p>The normalized Rosenbluth factor of the final ensemble is then given
by </p>
<div id="eq:normalized-rosenbluth-factor">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’²</mi><mo>=</mo><munderover><mo>âˆ</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>w</mi><mi>i</mi></msub><mi>M</mi></mfrac><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathcal{W} = \prod^n_{i=1} \frac{w_i}{M} \,.
    \label{eq:normalized-rosenbluth-factor}</annotation></semantics></math>
</div>
<p> As shown in <a href="#sec:smc-correctness">Sec. smc-correctness</a>,
we can derive an <em>unbiased</em> estimate for the desired ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’µ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msub><mi>ğ’µ</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{Z}[\mathbfit{x}]/\mathcal{Z}_0[\mathbfit{x}] = \mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
based on the Rosenbluth factor: </p>
<div id="eq:smc-marginal">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>ğ’«</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi mathvariant="normal">P</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mspace width="0.222em"></mspace><mi>ğ’²</mi></mrow><annotation encoding="application/x-tex">\hat{\mathcal{P}}[\mathbfit{x}] = \mathrm{P}(x_0)\ \mathcal{W}
    \label{eq:smc-marginal}</annotation></semantics></math>
</div>
<p> with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">P</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{P}(x_0)</annotation></semantics></math>
being the probability of the initial output
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>0</mn></msub><annotation encoding="application/x-tex">x_0</annotation></semantics></math>.
The particle filter can therefore be integrated into the DPWS algorithm
to compute the marginal density
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>,
substituting the brute-force estimate given in <a
href="#eq:marginal-naive">eq:marginal-naive</a>. We call the resulting
algorithm to compute the mutual information <em>RR-PWS</em>.</p>
<h3 id="intuitive-justification-of-the-algorithm">Intuitive
Justification of the Algorithm</h3>
<p>First note that steps 1 and 2(a) of the procedure above involve just
propagating
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
trajectories in parallel, according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]=\exp(-\mathcal{U}_0[\mathbfit{s}])</annotation></semantics></math>.
The interesting steps are 2(b-c) where we eliminate or duplicate some of
the trajectories according to the Boltzmann weights of the most recent
segment. Note, that in general the list of indices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msubsup><mi>â„“</mi><mi>i</mi><mn>1</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>â„“</mi><mi>i</mi><mi>M</mi></msubsup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\ell^1_i,\ldots,\ell^M_i)</annotation></semantics></math>
that are sampled in step 2(c) will contain duplicates
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>â„“</mi><mi>i</mi><mi>k</mi></msubsup><mo>=</mo><msubsup><mi>â„“</mi><mi>i</mi><msup><mi>k</mi><mi>â€²</mi></msup></msubsup></mrow><annotation encoding="application/x-tex">\ell^k_i=\ell^{k^\prime}_i</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>â‰ </mo><msup><mi>k</mi><mi>â€²</mi></msup></mrow><annotation encoding="application/x-tex">k\neq k^\prime</annotation></semantics></math>),
thus cloning the corresponding trajectory. Concomitantly, the indices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>â„“</mi><mi>i</mi><mn>1</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>â„“</mi><mi>i</mi><mi>M</mi></msubsup></mrow><annotation encoding="application/x-tex">\ell^1_i, \ldots, \ell^M_i</annotation></semantics></math>
may not include every original index
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">1,\ldots,M</annotation></semantics></math>,
therefore eliminating some trajectories. Since indices of trajectories
with high Boltzmann weight are more likely to be sampled from <a
href="#eq:index-prob">eq:index-prob</a>, this scheme biases the sampling
distribution towards trajectories with large Boltzmann weight, ensuring
that we are only spending computational effort on propagating
trajectories which contribute significantly to the marginalization
integral.</p>
<p>Hence, at its heart, the particle filter is an importance sampling
scheme. It produces samples that are biased towards the ideal importance
sampling distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\exp(-\mathcal{U}_0[\mathbfit{s}])\exp(-\Delta\mathcal{U}[\mathbfit{s},\mathbfit{x}])</annotation></semantics></math>,
i.e., towards to the Boltzmann distribution of the interacting ensemble.
The Rosenbluth factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’²</mi><annotation encoding="application/x-tex">\mathcal{W}</annotation></semantics></math>
represents the importance sampling weight which would be required to
correct for the sampling bias when computing averages using the sampled
trajectories. Importantly for our case, the Rosenbluth factor can also
be used to estimate the marginal probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>.
For illustration of the algorithm, one iteration of the particle filter
is presented schematically in <a href="#fig:smc">Fig. smc</a>.</p>
<h3 id="sec:smc-correctness" id="detailed-justification">Detailed
Justification</h3>
<p>This subsection justifies the marginal probability estimate shown in
<a href="#eq:smc-marginal">eq:smc-marginal</a> in greater detail, and
may be skipped on first reading. We show that the bootstrap particle
filter provides a consistent estimator for the marginal probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>,
or, equivalently, the ratio of partition functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’µ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><msub><mi>ğ’µ</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{Z}[\mathbfit{x}]/\mathcal{Z}_0[\mathbfit{x}]</annotation></semantics></math>.
The result that this estimate is also unbiased is more difficult to
establish; a proof is given by Del Moral <span class="citation"
data-cites="1997.Moral">Â [<a href="#ref-1997.Moral"
role="doc-biblioref">16</a>]</span>.</p>
<p>We structure our justification of the particle filter into three
steps. We first give a brief description of how a resampling procedure
can generally be used to generate samples approximating a target
distribution when only samples from a different distribution are
available. Secondly, we use these insights to explain how the resampling
procedure used in the particle filter generates trajectories whose
distribution is biased towards
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}|\mathbfit{x}]</annotation></semantics></math>,
even though we only generate trajectories according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>.
Finally, we use this result to show that the particle filter provides a
consistent estimate for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>.</p>
<h4 id="sampling-and-resampling">Sampling and resampling</h4>
<p>Sampling and then resampling is a strategy to use samples
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ğ’”</mi><mn>1</mn></msup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msup><mi>ğ’”</mi><mi>M</mi></msup></mrow><annotation encoding="application/x-tex">\mathbfit{s}^1,\ldots,\mathbfit{s}^M</annotation></semantics></math>
from a given prior distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">f[\mathbfit{s}]</annotation></semantics></math>
to generate <em>approximate</em> <a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a> samples from a different
distribution of interest, with density proportional to the product
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mi>g</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">h[\mathbfit{s}]=f[\mathbfit{s}]g[\mathbfit{s}]</annotation></semantics></math>.
In general,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">h[\mathbfit{s}]</annotation></semantics></math>
is not normalized, and we denote the corresponding normalized
probability density by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>h</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>h</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mi>/</mi><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mi>h</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\hat{h}[\mathbfit{s}]=h[\mathbfit{s}]/\int\mathcal{D}[\mathbfit{s}]h[\mathbfit{s}]</annotation></semantics></math>.
To generate samples from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>h</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\hat{h}[\mathbfit{s}]</annotation></semantics></math>,
we assign each of the existing samples from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">f[\mathbfit{s}]</annotation></semantics></math>
a normalized weight </p>
<div id="eq:weights-appendix">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>k</mi></msup><mo>=</mo><mfrac><mrow><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msup><mi>ğ’”</mi><mi>k</mi></msup><mo stretchy="false" form="postfix">]</mo></mrow><mrow><munderover><mo>âˆ‘</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msup><mi>ğ’”</mi><mi>j</mi></msup><mo stretchy="false" form="postfix">]</mo></mrow></mfrac><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">W^k = \frac{g[\mathbfit{s}^k]}{\sum^M_{j=1}g[\mathbfit{s}^j]}\,.
    \label{eq:weights-appendix}</annotation></semantics></math>
</div>
<p> Then, by sampling from the discrete set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msup><mi>ğ’”</mi><mn>1</mn></msup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msup><mi>ğ’”</mi><mi>M</mi></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathbfit{s}^1,\ldots,\mathbfit{s}^M\}</annotation></semantics></math>
according to the assigned weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mn>1</mn></msup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msup><mi>W</mi><mi>M</mi></msup></mrow><annotation encoding="application/x-tex">W^1,\ldots,W^M</annotation></semantics></math>,
we select samples that are approximately distributed according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>h</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\hat{h}[\mathbfit{s}]</annotation></semantics></math>.
Indeed, for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>â†’</mo><mi>âˆ</mi></mrow><annotation encoding="application/x-tex">M\rightarrow\infty</annotation></semantics></math>
the distribution of the resulting samples approaches the density
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>h</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\hat{h}[\mathbfit{s}]</annotation></semantics></math>
<span class="citation" data-cites="1992.Smith">Â [<a
href="#ref-1992.Smith" role="doc-biblioref">17</a>]</span>. We use
resampling at each iteration of the algorithm of <a href="#sec:smc">Sec.
smc</a> to regularly prune those trajectories with low overall
contribution to the marginalization integral.</p>
<h4 id="particle-filter">Particle filter</h4>
<p>In the bootstrap particle filter, at each iteration, we start with a
set of trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mn>1</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mi>M</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathbfit{s}^1_{[0,i-1]},\ldots,\mathbfit{s}^M_{[0,i-1]}</annotation></semantics></math>.
In each iteration of the particle filter, the goal is to produce a set
of elongated trajectories (from time step
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">(i-1) \to i</annotation></semantics></math>)
whose distribution tends towards
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i]}]</annotation></semantics></math>.
By iterating such a procedure, we can generate a set of trajectories
distributed approximately according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}_{[0,n]}|\mathbfit{x}_{[0,n]}]</annotation></semantics></math>
for any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n&gt;1</annotation></semantics></math>.
Thus, the particle filter is a biased sampling scheme which provides an
approximation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}_{[0,n]}|\mathbfit{x}_{[0,n]}]</annotation></semantics></math>.
Moreover, using the particle filter we can also compute the
corresponding importance weights which can be used to compute the
marginal probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}_{[0,n]}]</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>â€¦</mi></mrow><annotation encoding="application/x-tex">n=1,2,\ldots</annotation></semantics></math>.</p>
<p>We now take a closer look at one iteration of the particle filter.
Start with a set of trajectories in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msub><mi>Ï„</mi><mn>0</mn></msub><mo>,</mo><msub><mi>Ï„</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\tau_0,\tau_{i-1}]</annotation></semantics></math>,
denoted by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">{</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mn>1</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mi>M</mi></msubsup><mo stretchy="true" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\left\{\mathbfit{s}^1_{[0,i-1]},\ldots,\mathbfit{s}^M_{[0,i-1]}\right\}</annotation></semantics></math>.
These trajectories are then propagated forward to time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\tau_i</annotation></semantics></math>,
by adding a new segment
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">\mathbfit{s}^k_{[i-1,i]}</annotation></semantics></math>
to the trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">\mathbfit{s}^k_{[0,i-1]}</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">k=1,\ldots,M</annotation></semantics></math>.
Each new segment is generated from the distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><mo stretchy="false" form="prefix">|</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}^k_{[i-1,i]}|\mathbfit{s}^k_{[0,i-1]}]</annotation></semantics></math>
such that the propagation step results in a set of trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mn>1</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>M</mi></msubsup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathbfit{s}^1_{[0,i]},\ldots,\mathbfit{s}^M_{[0,i]}\}</annotation></semantics></math>,
distributed according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">f[\mathbfit{s}_{[0,i]}]=\mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i-1]}]</annotation></semantics></math>.</p>
<p>Next, we resample from the set of trajectories, with the goal of
producing a set of trajectories distributed according to the target
density
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>h</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\hat{h}[\mathbfit{s}] = \mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i]}]</annotation></semantics></math>.
Thus, we have to find the appropriate weighting function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">g[\mathbfit{s}_{[0,i]}]</annotation></semantics></math>
in order to approximately produce samples according to the target
distribution. By choosing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mrow><mo stretchy="true" form="prefix">{</mo><mi>âˆ’</mi><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo>,</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo stretchy="true" form="postfix">}</mo></mrow><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo>,</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">g[\mathbfit{s}_{[0,i]}] = \exp\left\{ -\Delta\mathcal{U}[\mathbfit{s}_{[i-1,i]}, \mathbfit{x}_{[i-1,i]}] \right\} = \mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]},\mathbfit{s}_{[0,i]}]</annotation></semantics></math>,
we generate normalized weights </p>
<div id="eq:normalized-weights">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>W</mi><mi>i</mi><mi>k</mi></msubsup><mo>=</mo><mfrac><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo>,</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><mo stretchy="false" form="postfix">]</mo></mrow><mrow><munderover><mo>âˆ‘</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo>,</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>j</mi></msubsup><mo stretchy="false" form="postfix">]</mo></mrow></mfrac><mspace width="0.167em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">W^k_i = \frac{\mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]},\mathbfit{s}^k_{[0,i]}]}{\sum^M_{j=1} \mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]},\mathbfit{s}^j_{[0,i]}]}\,,
    \label{eq:normalized-weights}</annotation></semantics></math>
</div>
<p> cf. <a href="#eq:weights-appendix">eq:weights-appendix</a>. Note
that this is the same choice of weighting function as in <a
href="#sec:smc">Sec. smc</a>, <a
href="#eq:index-prob">eq:index-prob</a>. By comparison with the notation
used there, we see that the Boltzmann factors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>U</mi><mi>i</mi><mi>k</mi></msubsup><annotation encoding="application/x-tex">U^k_i</annotation></semantics></math>
and Rosenbluth weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math>
were defined such that we can express the normalized weight equivalently
as </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>W</mi><mi>i</mi><mi>k</mi></msubsup><mo>=</mo><mfrac><msup><mi>e</mi><mrow><mi>âˆ’</mi><msubsup><mi>U</mi><mi>i</mi><mi>k</mi></msubsup></mrow></msup><msub><mi>w</mi><mi>i</mi></msub></mfrac><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">W^k_i = \frac{e^{-U^k_i}}{w_i} \,.</annotation></semantics></math>
<p>Why is this choice of weighting function the correct one? First,
observe that resampling with the normalized weights of <a
href="#eq:normalized-weights">eq:normalized-weights</a> produces samples
approximately distributed according to </p>
<div id="eq:h-unnormalized">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>h</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo>,</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    h[\mathbfit{s}_{[0,i]}] &amp;= f[\mathbfit{s}_{[0,i]}] g[\mathbfit{s}_{[0,i]}] \\
    &amp;= \mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i-1]}]\  \mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]},\mathbfit{s}_{[0,i]}]\,.
\end{aligned}
\label{eq:h-unnormalized}</annotation></semantics></math>
</div>
<p> What remains to be shown is that this density
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">h[\mathbfit{s}_{[0,i]}]</annotation></semantics></math>,
when normalized, becomes the desired target distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}_{[0,i]}| \mathbfit{x}_{[0,i]}]</annotation></semantics></math>.</p>
<p>To do so, we need to rewrite the expression for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo>,</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">g[\mathbfit{s}_{[0,i]}]=\mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]},\mathbfit{s}_{[0,i]}]</annotation></semantics></math>
using Bayesâ€™ theorem </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mfrac><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo>,</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow></mfrac><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">g[\mathbfit{s}_{[0,i]}]=\frac{ \mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i-1]},\mathbfit{x}_{[i-1,i]}]\ \mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]}]}{\mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i-1]}]}\,.</annotation></semantics></math>
<p> Notice that the first term of the numerator can be written as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i]}]</annotation></semantics></math>.
After inserting this result into <a
href="#eq:h-unnormalized">eq:h-unnormalized</a>, we obtain </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">h[\mathbfit{s}_{[0,i]}] = \mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i]}]\ \mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]}]\,.</annotation></semantics></math>
<p> The second term in this product is a constant, since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>
is fixed. The first term is a normalized probability density for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><annotation encoding="application/x-tex">\mathbfit{s}_{[0,i]}</annotation></semantics></math>.
Therefore we find that the normalized density corresponding to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">h[\mathbfit{s}_{[0,i]}]</annotation></semantics></math>
is </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>h</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\hat{h}[\mathbfit{s}_{[0,i]}] = \mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i]}]\,.</annotation></semantics></math>
<p> Consequently, this is the distribution that is approximated by the
set of trajectories at the end of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
iteration of the particle filter, which is what we wanted to show. At
its heart, the particle filter is therefore an algorithm to produce
samples that are approximately distributed according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}|\mathbfit{x}]</annotation></semantics></math>.</p>
<h4 id="marginal-probability-estimate">Marginal probability
estimate</h4>
<p>We now use these insights to derive an estimate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>.
We start by noting that the marginal density of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
output segment,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]}]</annotation></semantics></math>,
is given by </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo>,</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    &amp;\mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]}] \\
    &amp;=\int\mathcal{D}[\mathbfit{s}_{[0,i]}]\ 
    \mathcal{P}[\mathbfit{x}_{[i-1,i]},\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i-1]}]\\
    &amp;=\int\mathcal{D}[\mathbfit{s}_{[0,i]}]\ 
    \mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i-1]}]\ 
    g[\mathbfit{s}_{[0,i]}]\,.
    \end{aligned}</annotation></semantics></math>
<p> The third line follows from the definition of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo>,</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">g[\mathbfit{s}_{[0,i]}]=\mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]},\mathbfit{s}_{[0,i]}]</annotation></semantics></math>.
Hence, we find that the probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]}]</annotation></semantics></math>
can be expressed as the average </p>
<div id="eq:marginal-segment-average">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">âŸ¨</mo><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo stretchy="true" form="postfix">âŸ©</mo></mrow><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow></msub><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]}] = \left\langle
    g[\mathbfit{s}_{[0,i]}]
    \right\rangle_{\mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i-1]}]}\,.
    \label{eq:marginal-segment-average}</annotation></semantics></math>
</div>
<p> In principle, this average can be computed using a Monte Carlo
scheme, using trajectories generated from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i-1]}]</annotation></semantics></math>.
Notice that at each iteration of the particle filter, we <em>do</em>
dispose of a set of trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mn>1</mn></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>M</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathbfit{s}^1_{[0,i]},\ldots,\mathbfit{s}^M_{[0,i]}</annotation></semantics></math>
which are approximately distributed according to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}_{[0,i]}|\mathbfit{x}_{[0,i-1]}]</annotation></semantics></math>
above. Therefore, we can compute the average <a
href="#eq:marginal-segment-average">eq:marginal-segment-average</a>
directly from the trajectories that are present for each iteration of
the particle filter. With the notation from <a href="#sec:smc">Sec.
smc</a>, using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false" form="prefix">[</mo><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><msubsup><mi>U</mi><mi>i</mi><mi>k</mi></msubsup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">g[\mathbfit{s}^k_{[0,i]}]=\exp(-U^k_i)</annotation></semantics></math>,
we thus obtain the estimate </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo><mo>â‰ˆ</mo><mfrac><mn>1</mn><mi>M</mi></mfrac><munderover><mo>âˆ‘</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msup><mi>e</mi><mrow><mi>âˆ’</mi><msubsup><mi>U</mi><mi>i</mi><mi>k</mi></msubsup></mrow></msup><mo>=</mo><mfrac><msub><mi>w</mi><mi>i</mi></msub><mi>M</mi></mfrac><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}_{[i-1,i]}|\mathbfit{x}_{[0,i-1]}] \approx
    \frac{1}{M}\sum^M_{k=1} e^{-U^k_i} = \frac{w_i}{M}\,.</annotation></semantics></math>
<p> The probability of the entire output trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
is given by the product </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi mathvariant="normal">P</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">]</mo><mi>â‹¯</mi><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ’™</mi><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}] = \mathrm{P}(x_0) \mathcal{P}[\mathbfit{x}_{[0,1]}|x_0]\cdots \mathcal{P}[\mathbfit{x}_{[n-1,n]}|\mathbfit{x}_{[0,n-1]}]</annotation></semantics></math>
<p> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">P</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{P}(x_0)</annotation></semantics></math>
is the probability of the initial output state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>0</mn></msub><annotation encoding="application/x-tex">x_0</annotation></semantics></math>
which is assumed to be known. In conclusion, we arrive at the following
estimate for the marginal output probability </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>ğ’«</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi mathvariant="normal">P</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><munderover><mo>âˆ</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>w</mi><mi>i</mi></msub><mi>M</mi></mfrac></mrow><annotation encoding="application/x-tex">\hat{\mathcal{P}}[\mathbfit{x}] = \mathrm{P}(x_0) \prod^n_{i=1} \frac{w_i}{M}</annotation></semantics></math>
<p> which is precisely <a
href="#eq:smc-marginal">eq:smc-marginal</a>.</p>
<h3 id="tuning-the-particle-filter">Tuning the Particle Filter</h3>
<p>For the efficiency of the particle filter, it is important to
carefully choose the number of segments
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.
When segments are very short (i.e., when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
is large), the accumulated weights (<a
href="#eq:weight_segment">eq:weight_segment</a>) tend to differ very
little between newly generated segments
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ğ’”</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><mi>k</mi></msubsup><annotation encoding="application/x-tex">\mathbfit{s}^k_{[i-1,i]}</annotation></semantics></math>.
Hence, the pruning and enrichment of the segments is dominated by noise.
In contrast, when the segments are very long, the distribution of
Boltzmann weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>U</mi><mi>i</mi><mi>k</mi></msubsup><annotation encoding="application/x-tex">U^k_i</annotation></semantics></math>
becomes very wide. Then only a small number of segments contribute
substantially to the corresponding Rosenbluth weight
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math>.
Hence, to correctly choose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
we need a measure that quantifies the variance in the trajectory weights
of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
particles. To this end, we follow Martino et al. <span class="citation"
data-cites="2017.Martino">Â [<a href="#ref-2017.Martino"
role="doc-biblioref">18</a>]</span> and introduce an effective sample
size (ESS) </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>M</mi><mi>i</mi><mtext mathvariant="normal">(eff)</mtext></msubsup><mo>=</mo><mfrac><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup><mrow><munderover><mo>âˆ‘</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>âˆ’</mi><msubsup><mi>U</mi><mi>i</mi><mi>k</mi></msubsup></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">M^\text{(eff)}_i = \frac{w_i^2}{\sum^M_{k=1} \left(e^{-U^k_i}\right)^2},</annotation></semantics></math>
<p> which lies in the range
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>â‰¤</mo><msubsup><mi>M</mi><mi>i</mi><mtext mathvariant="normal">(eff)</mtext></msubsup><mo>â‰¤</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">1 \leq M^\text{(eff)}_i \leq M</annotation></semantics></math>;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>M</mi><mi>i</mi><mtext mathvariant="normal">(eff)</mtext></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M^\text{(eff)}_i = 1</annotation></semantics></math>
if one trajectory has a much higher weight than all the others and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>M</mi><mi>i</mi><mtext mathvariant="normal">(eff)</mtext></msubsup><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M^\text{(eff)}_i = M</annotation></semantics></math>
if all trajectories have the same weight. As a rule of thumb, we
resample only when the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>M</mi><mi>i</mi><mtext mathvariant="normal">(eff)</mtext></msubsup><annotation encoding="application/x-tex">M^\text{(eff)}_i</annotation></semantics></math>
drops below
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">M/2</annotation></semantics></math>.
Additionally, as recommended in Ref.Â <span class="citation"
data-cites="2011.Doucet">Â [<a href="#ref-2011.Doucet"
role="doc-biblioref">19</a>]</span>, we use the <em>systematic
sampling</em> algorithm to randomly draw the indices in step 2(c) which
helps to reduce the variance; we find, however, the improvement over
simple sampling is very minor. Using these techniques, the only
parameter that needs to be chosen by hand for the particle filter is the
ensemble size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>.</p>
<h2 id="sec:thermodynamic-integration" id="ti-pws">TI-PWS</h2>
<p>Thermodynamic integration PWS (TI-PWS), is based on the analogy of
marginalization integrals with free-energy computations. As before, we
view the problem of computing the marginal probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
as equivalent to that of computing the free-energy difference between
ensembles defined by the potentials
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}_0[\mathbfit{s}, \mathbfit{x}]</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}[\mathbfit{s}, \mathbfit{x}]</annotation></semantics></math>,
respectively. For TI-PWS, we define a potential
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}_\theta[\mathbfit{s},\mathbfit{x}]</annotation></semantics></math>
with a continuous parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î¸</mi><mo>âˆˆ</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\theta\in[0,1]</annotation></semantics></math>
that allows us to transform the ensemble from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ’°</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\mathcal{U}_0</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’°</mi><mo>=</mo><msub><mi>ğ’°</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{U}=\mathcal{U}_1</annotation></semantics></math>.
The corresponding partition function is </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’µ</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><msup><mi>e</mi><mrow><mi>âˆ’</mi><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathcal{Z}_\theta[\mathbfit{x}]=\int\mathcal{D}[\mathbfit{s}]\ e^{-\mathcal{U}_\theta[\mathbfit{s},\mathbfit{x}]} \,.</annotation></semantics></math>
<p> For instance, for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>â‰¤</mo><mi>Î¸</mi><mo>â‰¤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0\leq\theta\leq 1</annotation></semantics></math>,
we can define our potential as </p>
<div id="eq:ti-hamiltonian">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><msub><mi>ğ’°</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>+</mo><mi>Î¸</mi><mspace width="0.167em"></mspace><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}_\theta[\mathbfit{s},\mathbfit{x}]=\mathcal{U}_0[\mathbfit{s}, \mathbfit{x}]+\theta\,\Delta\mathcal{U}[\mathbfit{s},\mathbfit{x}]\,,
    \label{eq:ti-hamiltonian}</annotation></semantics></math>
</div>
<p> such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mi>âˆ’</mi><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’”</mi><msup><mo stretchy="false" form="postfix">]</mo><mi>Î¸</mi></msup></mrow><annotation encoding="application/x-tex">e^{-\mathcal{U}_\theta[\mathbfit{s},\mathbfit{x}]}=\mathcal{P}[\mathbfit{s}]\mathcal{P}[\mathbfit{x}|\mathbfit{s}]^\theta</annotation></semantics></math>.
Note that this is the simplest choice for a continuous transformation
between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ’°</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\mathcal{U}_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ’°</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\mathcal{U}_1</annotation></semantics></math>,
but by no means the only one. For reasons of computational efficiency,
it can be beneficial to choose a different path between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ’°</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\mathcal{U}_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ’°</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\mathcal{U}_1</annotation></semantics></math>,
depending on the specific systemÂ <span class="citation"
data-cites="1998.Gelman">Â [<a href="#ref-1998.Gelman"
role="doc-biblioref">5</a>]</span>. Here we will not consider other
paths however, and derive the thermodynamic integration estimate for the
potential given in <a
href="#eq:ti-hamiltonian">eq:ti-hamiltonian</a>.</p>
<p>To derive the thermodynamic integration estimate for the free-energy
difference, we first compute the derivative of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><msub><mi>ğ’µ</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\ln\mathcal{Z}_\theta[\mathbfit{x}]</annotation></semantics></math>
with respect
toÂ <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¸</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>:
</p>
<div id="eq:z-derivative">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mfrac><mi>âˆ‚</mi><mrow><mi>âˆ‚</mi><mi>Î¸</mi></mrow></mfrac><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><msub><mi>ğ’µ</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mn>1</mn><mrow><msub><mi>ğ’µ</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></mfrac><mfrac><mi>âˆ‚</mi><mrow><mi>âˆ‚</mi><mi>Î¸</mi></mrow></mfrac><mo>âˆ«</mo><mi>ğ’Ÿ</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><msup><mi>e</mi><mrow><mi>âˆ’</mi><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>âˆ’</mi><msub><mrow><mo stretchy="true" form="prefix">âŸ¨</mo><mfrac><mrow><mi>âˆ‚</mi><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><mrow><mi>âˆ‚</mi><mi>Î¸</mi></mrow></mfrac><mo stretchy="true" form="postfix">âŸ©</mo></mrow><mi>Î¸</mi></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>âˆ’</mi><msub><mrow><mo stretchy="true" form="prefix">âŸ¨</mo><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="true" form="postfix">âŸ©</mo></mrow><mi>Î¸</mi></msub><mspace width="0.167em"></mspace><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \frac{\partial}{\partial \theta} \ln\mathcal{Z}_\theta[\mathbfit{x}] &amp;= \frac{1}{\mathcal{Z}_\theta[\mathbfit{x}]} \frac{\partial}{\partial \theta} \int\mathcal{D}[\mathbfit{s}]\  e^{-\mathcal{U}_\theta[\mathbfit{s},\mathbfit{x}]} \\
    &amp;= -\left\langle \frac{\partial \mathcal{U}_\theta[\mathbfit{s},\mathbfit{x}]}{\partial\theta} \right\rangle_\theta\\
    &amp;= -\left\langle
    \Delta\mathcal{U}[\mathbfit{s},\mathbfit{x}]
    \right\rangle_\theta\,.
\end{aligned}
\label{eq:z-derivative}</annotation></semantics></math>
</div>
<p> Thus, the derivative of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><msub><mi>ğ’µ</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\ln\mathcal{Z}_\theta[\mathbfit{x}]</annotation></semantics></math>
is an average of the Boltzmann weight with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’«</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}_\theta[\mathbfit{s}|\mathbfit{x}]</annotation></semantics></math>
which is the ensemble distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
given by </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’«</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mfrac><mn>1</mn><mrow><msub><mi>ğ’µ</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></mfrac><msup><mi>e</mi><mrow><mi>âˆ’</mi><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\mathcal{P}_\theta[\mathbfit{s}|\mathbfit{x}] = \frac{1}{\mathcal{Z}_\theta[\mathbfit{x}]} e^{-\mathcal{U}_\theta[\mathbfit{s}, \mathbfit{x}]}\,.</annotation></semantics></math>
<p> Integrating <a href="#eq:z-derivative">eq:z-derivative</a> with
respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¸</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
leads to the formula for the free-energy difference </p>
<div id="eq:ti-estimate">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î”</mi><mi>â„±</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>âˆ’</mi><msubsup><mo>âˆ«</mo><mn>0</mn><mn>1</mn></msubsup><mi>d</mi><mi>Î¸</mi><mspace width="0.222em"></mspace><msub><mrow><mo stretchy="true" form="prefix">âŸ¨</mo><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="true" form="postfix">âŸ©</mo></mrow><mi>Î¸</mi></msub></mrow><annotation encoding="application/x-tex">\Delta\mathcal{F}[\mathbfit{x}] = -\int^1_0 d\theta\ \left\langle 
    \Delta\mathcal{U}[\mathbfit{s}, \mathbfit{x}]
    \right\rangle_\theta
    \label{eq:ti-estimate}</annotation></semantics></math>
</div>
<p> which is the fundamental identity underlying thermodynamic
integration.</p>
<p>To compute the free-energy difference using <a
href="#eq:ti-estimate">eq:ti-estimate</a>, we evaluate the integral with
respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¸</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
numerically using Gaussian quadrature, while the inner average
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mo stretchy="true" form="prefix">âŸ¨</mo><mi mathvariant="normal">Î”</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="true" form="postfix">âŸ©</mo></mrow><mi>Î¸</mi></msub><annotation encoding="application/x-tex">\left\langle \Delta\mathcal{U}[\mathbfit{s}, \mathbfit{x}] \right\rangle_\theta</annotation></semantics></math>
is computed using MCMC simulations. To perform MCMC simulations in
trajectory space we use ideas from transition path sampling (TPS).
Specifically, we define a MCMC proposal distribution for trajectories
using forward shooting and backward shooting <span class="citation"
data-cites="2002.Bolhuis">Â [<a href="#ref-2002.Bolhuis"
role="doc-biblioref">7</a>]</span>. These proposals regrow either the
end, or the beginning of a trajectory, respectively. A proposal is
accepted according to the Metropolis criterionÂ <span class="citation"
data-cites="1953.Metropolis">Â [<a href="#ref-1953.Metropolis"
role="doc-biblioref">20</a>]</span>. Since the efficiency of MCMC
samplers strongly depends on the proposal moves that are employed, we
are certain that better MCMC estimates are possible with more
sophisticated proposal distributions.</p>
<h3 id="sec:mcmc" id="mcmc-sampling-in-trajectory-space">MCMC Sampling
in Trajectory Space</h3>
<p>TI-PWS relies on the computation of averages with respect to the
ensembles corresponding to the interaction parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¸</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>,
given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’«</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>âˆ</mo><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}_\theta[\mathbfit{s}|\mathbfit{x}]\propto\exp(-\mathcal{U}_\theta[\mathbfit{s}, \mathbfit{x}])</annotation></semantics></math>.
Sampling from this family of distributions using the SSA (Gillespie)
algorithm is not possible. Instead, in this section, we show different
ways of how to implement a Markov Chain Monte Carlo (MCMC) sampler in
trajectory space to generate correctly distributed trajectories.</p>
<p>We can build an MCMC sampler in trajectory space using the
Metropolis-Hastings algorithm. To create a Markov chain in trajectory
space, we need to find a suitable proposal kernel, that generates a new
trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ’”</mi><mi>â€²</mi></msup><annotation encoding="application/x-tex">\mathbfit{s}^\prime</annotation></semantics></math>
from a given trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
with probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’”</mi><mo>â†’</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">T(\mathbfit{s}\rightarrow\mathbfit{s}^\prime)</annotation></semantics></math>.
We accept the proposal using the Metropolis criterion with probability
</p>
<div id="eq:metropolis-acceptance">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><mo>,</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mi>min</mi><mo>&#8289;</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><msup><mi>e</mi><mrow><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>âˆ’</mo><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup><mfrac><mrow><mi>T</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><mo>â†’</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’”</mi><mo>â†’</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A(\mathbfit{s}^\prime,\mathbfit{s})=\min\left( 1, e^{\mathcal{U}_\theta[\mathbfit{s}, \mathbfit{x}] - \mathcal{U}_\theta[\mathbfit{s}^\prime, \mathbfit{x}]}\frac{T(\mathbfit{s}^\prime\rightarrow\mathbfit{s})}{T(\mathbfit{s}\rightarrow\mathbfit{s}^\prime)} \right)
    \label{eq:metropolis-acceptance}</annotation></semantics></math>
</div>
<p> to create a chain of trajectories with stationary distribution given
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’«</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><msup><mi>e</mi><mrow><mi>âˆ’</mi><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup><mi>/</mi><msub><mi>ğ’µ</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}_\theta[\mathbfit{s}|\mathbfit{x}]=e^{-\mathcal{U}_\theta[\mathbfit{s}, \mathbfit{x}]}/\mathcal{Z}_\theta[\mathbfit{x}]</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>â‰¤</mo><mi>Î¸</mi><mo>â‰¤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0\leq\theta\leq 1</annotation></semantics></math>.
To ensure efficient convergence of the resulting Markov chain to its
stationary distribution, the proposal kernel must balance two
conflicting requirements. To efficiently explore the state space per
unit amount of CPU time, the proposed trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ’”</mi><mi>â€²</mi></msup><annotation encoding="application/x-tex">\mathbfit{s}^\prime</annotation></semantics></math>
must be sufficiently different from the original trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>,
while at the same time it should not be so different that the acceptance
probability becomes too low. Thus, the design of the proposal kernel is
crucial for an efficient MCMC sampler, and we will discuss various
strategies to create trial trajectories. Since different types of trial
moves can easily be combined in a Metropolis-Hastings algorithm, the
most efficient samplers often incorporate multiple complementary
proposal strategies to improve the exploration speed of the trajectory
space.</p>
<p>The simplest (and naÃ¯ve) proposal kernel is to generate an entirely
new trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ’”</mi><mi>â€²</mi></msup><annotation encoding="application/x-tex">\mathbfit{s}^\prime</annotation></semantics></math>
independent of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>,
by sampling directly from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>
using the SSA. Hence, the transition kernel is given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’”</mi><mo>â†’</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">T(\mathbfit{s}\rightarrow\mathbfit{s}^\prime)=\mathcal{P}[\mathbfit{s}^\prime]</annotation></semantics></math>
and a proposal
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’”</mi><mo>â†’</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup></mrow><annotation encoding="application/x-tex">\mathbfit{s}\rightarrow\mathbfit{s}^\prime</annotation></semantics></math>
is accepted with probability </p>
<div id="eq:acceptance-rate">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>A</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><mo>,</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mrow><mi>min</mi><mo>&#8289;</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><msup><mi>e</mi><mrow><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>âˆ’</mo><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow></msup><mfrac><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><mo stretchy="false" form="postfix">]</mo></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mrow><mi>min</mi><mo>&#8289;</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mfrac><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><msup><mi>ğ’”</mi><mi>â€²</mi></msup><msup><mo stretchy="false" form="postfix">]</mo><mi>Î¸</mi></msup></mrow><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’”</mi><msup><mo stretchy="false" form="postfix">]</mo><mi>Î¸</mi></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    A(\mathbfit{s}^\prime,\mathbfit{s}) &amp;= \min\left( 1, e^{\mathcal{U}_\theta[\mathbfit{s}, \mathbfit{x}] - \mathcal{U}_\theta[\mathbfit{s}^\prime, \mathbfit{x}]}\frac{\mathcal{P}[\mathbfit{s}]}{\mathcal{P}[\mathbfit{s}^\prime]} \right) \\
    &amp;= \min\left( 1, \frac{\mathcal{P}[\mathbfit{x}|\mathbfit{s}^\prime]^\theta}{\mathcal{P}[\mathbfit{x}|\mathbfit{s}]^\theta} \right)
\end{aligned}
\label{eq:acceptance-rate}</annotation></semantics></math>
</div>
<p> where the second line follows by using the definition of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ’°</mi><mi>Î¸</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}_\theta[\mathbfit{s},\mathbfit{x}]</annotation></semantics></math>
given in <a href="#eq:ti-hamiltonian">eq:ti-hamiltonian</a>. Although
this simple scheme is correct, it should not be used in practice to
compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>.
Indeed, on would get a better estimate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
by just using the same number of independent sample trajectories from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>
and using the brute-force scheme in <a
href="#eq:marginal-naive">eq:marginal-naive</a> without taking the
detour of using MCMC to estimate the normalization constant.</p>
<p>Instead, an idea from transition path sampling is to only regenerate
a part of the old trajectory as part of the proposal kernel <span
class="citation" data-cites="1998a.Dellago">Â [<a
href="#ref-1998a.Dellago" role="doc-biblioref">21</a>]</span>. By not
regenerating the entire trajectory, the new trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ’”</mi><mi>â€²</mi></msup><annotation encoding="application/x-tex">\mathbfit{s}^\prime</annotation></semantics></math>
is going to be correlated with the original trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>,
improving the acceptance rate. The simplest way to generate trial
trajectories using a partial update is a move termed <em>forward
shooting</em> in which a time point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï„</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
along the existing trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
is randomly selected, and a new trajectory segment is regrown from this
point to the end, resulting in the proposal
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ’”</mi><mi>â€²</mi></msup><annotation encoding="application/x-tex">\mathbfit{s}^\prime</annotation></semantics></math>.
Since the new segment is generated according to the unbiased input
statistics, the acceptance probability for the proposed trajectory is
given by <a href="#eq:acceptance-rate">eq:acceptance-rate</a>, i.e., the
same as if the entire trajectory had been regenerated. If the input
dynamics given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>
are time-reversible, we can also perform a <em>backward shooting</em>
move. Here, the beginning of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
is replaced by a new segment that is generated backwards in time.
Assuming that the initial condition is the inputâ€™s steady state
distribution, the corresponding acceptance probability of the backward
shooting move is again given by <a
href="#eq:acceptance-rate">eq:acceptance-rate</a>. Using these two moves
we create an MCMC sampler where both ends of the trajectory are
flexible, and thus if the trajectory is not too long, the chain will
quickly relax to its stationary distribution.</p>
<p>For long trajectories it can prove to be a problem that the middle
section is too inflexible when the proposal moves only regenerate either
the beginning or the end of a trajectory. Therefore, one could
additionally try to incorporate mid-section regrowth to make sure that
also the middle parts of the trajectory become flexible. To regrow a
middle segment with duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï„</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
of a trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>,
we have to generate a new segment of duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï„</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
according to the stochastic dynamics given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>
but with the additional condition that we have to connect <em>both</em>
endpoints of the new segment to the existing trajectory. Although the
starting point of the segment can be freely chosen, the challenge is to
ensure that the end point of the new segment satisfies the end-point
constraint. Stochastic processes that generate trajectories under the
condition of hitting a specific point after a given duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï„</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
are called stochastic bridging processes.</p>
<p>The simplest way to generate trajectories from a bridging process is
by generating a trajectory segment of length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï„</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
from the normal stochastic process and rejecting the segment if it does
not hit the correct end point <span class="citation"
data-cites="2009.Hobolth">Â [<a href="#ref-2009.Hobolth"
role="doc-biblioref">22</a>]</span>. Clearly, this strategy is only
feasible for very short segments and when the state space is discrete,
as otherwise almost every generated segment will be rejected due to not
hitting the correct end point. To avoid this problem, more efficient
algorithms have been developed to simulate stochastic bridges for some
types of stochastic processes. For diffusion processes, bridges can be
simulated efficiently by introducing a guiding term into the
corresponding Langevin equation <span class="citation"
data-cites="2017.Meulen">Â [<a href="#ref-2017.Meulen"
role="doc-biblioref">23</a>]</span>. For jump processes, bridges can be
simulated using particle filters <span class="citation"
data-cites="2015.Golightly">Â [<a href="#ref-2015.Golightly"
role="doc-biblioref">24</a>]</span>, by a weighted stochastic simulation
algorithm (wSSA) <span class="citation" data-cites="2019.Gillespie">Â [<a
href="#ref-2019.Gillespie" role="doc-biblioref">25</a>]</span>, or using
random time-discretization (uniformization) <span class="citation"
data-cites="2009.Hobolth">Â [<a href="#ref-2009.Hobolth"
role="doc-biblioref">22</a>]</span>.</p>
<p>Further techniques to create a trajectory space MCMC samplers have
been developed in the literature. Crooks <span class="citation"
data-cites="2000.Crooks">Â [<a href="#ref-2000.Crooks"
role="doc-biblioref">26</a>]</span> describes a scheme to create MCMC
moves for trajectories evolving in non-equilibrium dynamics, by making
MCMC moves to change the trajectoriesâ€™ noise histories. In the Particle
Markov Chain Monte Carlo (PMCMC) algorithm, proposal trajectories are
generated using a particle filter and accepted with an appropriate
Metropolis criterion <span class="citation"
data-cites="2010.Andrieu">Â [<a href="#ref-2010.Andrieu"
role="doc-biblioref">27</a>]</span>. Another class of efficient samplers
for Markov jump processes can be built using uniformization <span
class="citation" data-cites="2013.Rao">Â [<a href="#ref-2013.Rao"
role="doc-biblioref">28</a>]</span>.</p>
<h2 id="sec:pws_variants_benchmark">Simple Application and
Benchmark</h2>
<p>To demonstrate the power of our framework and illustrate how the
techniques of the previous sections can be used in practice, we apply
PWS to a simple chemical reaction network. We consider a linearly
coupled birth-death process which has been studied previously using a
Gaussian model <span class="citation" data-cites="2009.Tostevin">Â [<a
href="#ref-2009.Tostevin" role="doc-biblioref">8</a>]</span>, and by
Duso and Zechner <span class="citation" data-cites="2019.Duso">Â [<a
href="#ref-2019.Duso" role="doc-biblioref">9</a>]</span> using an
approximate technique, and we compare our results with these studies.
This simple birth-death system serves to illustrate the main ideas of
our approach and also highlights that linear systems can be distinctly
non-Gaussian.</p>
<p>The code used to produce the PWS estimates was written in the Julia
programming languageÂ <span class="citation"
data-cites="2017.Bezanson">Â [<a href="#ref-2017.Bezanson"
role="doc-biblioref">29</a>]</span> and has been made freely
availableÂ <span class="citation"
data-cites="manuel_reinhardt_2021_6334035 pws_github">Â [<a
href="#ref-manuel_reinhardt_2021_6334035" role="doc-biblioref">30</a>,<a
href="#ref-pws_github" role="doc-biblioref">31</a>]</span>. For
performing stochastic simulations we use the DifferentialEquations.jl
packageÂ <span class="citation" data-cites="2017.Rackauckas">Â [<a
href="#ref-2017.Rackauckas" role="doc-biblioref">32</a>]</span>.</p>
<p>We consider a stochastic process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>âˆ…</mi><mo>â‡Œ</mo><mi mathvariant="normal">X</mi></mrow><annotation encoding="application/x-tex">\emptyset\rightleftharpoons\mathrm{X}</annotation></semantics></math>
of
speciesÂ <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">X</mi><annotation encoding="application/x-tex">\mathrm{X}</annotation></semantics></math>
which is created at rate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\rho(t)</annotation></semantics></math>
and decays with constant rate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¼</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>
pÌ±er copy of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">X</mi><annotation encoding="application/x-tex">\mathrm{X}</annotation></semantics></math>.
This system receives information from an input signal that modulates the
birth rate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\rho(t)</annotation></semantics></math>.
For simplicity, we assume it is given by </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>Ï</mi><mn>0</mn></msub><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\rho(t)=\rho_0 s(t)</annotation></semantics></math>
<p> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\rho_0</annotation></semantics></math>
is a constant and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">s(t)</annotation></semantics></math>
is the input copy number at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
This is a simple model for gene expression, where the rate of production
of a protein
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">X</mi><annotation encoding="application/x-tex">\mathrm{X}</annotation></semantics></math>
is controlled by a transcription factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">S</mi><annotation encoding="application/x-tex">\mathrm{S}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">X</mi><annotation encoding="application/x-tex">\mathrm{X}</annotation></semantics></math>
itself has a characteristic decay rate. The input trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">s(t)</annotation></semantics></math>
themselves are generated via a separate birth-death process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>âˆ…</mi><mo>â‡Œ</mo><mi mathvariant="normal">S</mi></mrow><annotation encoding="application/x-tex">\emptyset\rightleftharpoons\mathrm{S}</annotation></semantics></math>
with production rate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Îº</mi><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>
and decay rate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î»</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.</p>
<p>We compute the trajectory mutual information for this system as a
function of the trajectory duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
of the input and output trajectories. FÌ±or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>â†’</mo><mi>âˆ</mi></mrow><annotation encoding="application/x-tex">T\rightarrow\infty</annotation></semantics></math>,
the trajectory mutual information is expected to increase linearly with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>,
since, on average, every additional output segment contains the same
additional amount of information on the input trajectory. Because we are
interested in the mutual information in steady state, the initial states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>s</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s_0,x_0)</annotation></semantics></math>
were drawn from the stationary distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">P</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>s</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{P}(s_0,x_0)</annotation></semantics></math>.
This distribution was obtained using a Gaussian approximation. This does
not influence the asymptotic rate of increase of the mutual information,
but leads to a nonzero mutual information already for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">T=0</annotation></semantics></math>.</p>
<figure id="fig:gene-expr">
<img src="../images/gene-expr-figure.svg"  />
<figcaption>Comparing different schemes to compute the mutual
information as a function of trajectory duration for a simple coupled
birth-death process with rates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Îº</mi><mo>=</mo><mn>50</mn><mo>,</mo><mi>Î»</mi><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>Ï</mi><mn>0</mn></msub><mo>=</mo><mn>10</mn><mo>,</mo><mi>Î¼</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\kappa = 50, \lambda=1, \rho_0=10, \mu = 10</annotation></semantics></math>
and steady-state initial condition. á¹®he top panels show example
trajectories of input and output as well as the mean (solid line) and
standard deviation (shaded region). Below, the mutual information is
shown as a function of trajectory duration. The inset shows an enlarged
version of the dotted rectangle near the origin. For short trajectories
all PWS estimates agree. Yet, for longer trajectories, DPWS and TI-PWS
require a much larger number of input trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
for computing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
than RR-PWS to converge. Results for the three PWS variants are compared
with the Duso and Zechner <span class="citation"
data-cites="2019.Duso">Â [<a href="#ref-2019.Duso"
role="doc-biblioref">9</a>]</span> estimate, and with the linear noise
approximation from Ref. <span class="citation"
data-cites="2009.Tostevin">Â [<a href="#ref-2009.Tostevin"
role="doc-biblioref">8</a>]</span>. We find excellent agreement between
the Duso scheme and RR-PWS. The Gaussian linear noise approximation
systematically underestimates the mutual information. All PWS estimates,
as well as the Duso approximation were computed using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>10</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">N=10^4</annotation></semantics></math>
samples from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s},\mathbfit{x}]</annotation></semantics></math>.
</figcaption>
</figure>
<p><a href="#fig:gene-expr">Figure gene-expr</a> shows the mutual
information as a function of the trajectory duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>.
We compare the three PWS variants and two approximate schemes. One is
that of Duso and Zechner <span class="citation"
data-cites="2019.Duso">Â [<a href="#ref-2019.Duso"
role="doc-biblioref">9</a>]</span>. To apply it, we used the code
publicly provided by the authors<a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a>, and to avoid making
modifications to this code, we chose a fixed initial condition
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>s</mi><mn>0</mn></msub><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo>=</mo><mn>50</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s_0=x_0=50)</annotation></semantics></math>
which causes the mutual information to be zero for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">T=0</annotation></semantics></math>.
The figure also shows the analytical result of a Gaussian model <span
class="citation" data-cites="2009.Tostevin">Â [<a
href="#ref-2009.Tostevin" role="doc-biblioref">8</a>]</span>, obtained
using the linear-noise approximation (see <a
href="#sec:gaussian-covariance">Sec. gaussian-covariance</a>).</p>
<p>WÌ±e find that the efficiency of the respective PWS variants depends on
the duration of the input-output trajectories. For short trajectories
all PWS variants yield very similar estimates for the mutual
information. However, for longer trajectories the estimates of DPWS and,
to a smaller degree, TI-PWS diverge, because of poor sampling of the
trajectory space in the estimate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>.
For longer trajectories, the estimate becomes increasingly dominated by
rare trajectories, which make an exceptionally large contribution to the
average of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>.
Missing these rare trajectories with a high weight tends to increase the
marginal entropy
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">H</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’³</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{H}(\mathcal{X})</annotation></semantics></math>
[see <a
href="#eq:marginal-entropy-estimate">eq:marginal-entropy-estimate</a>],
and thereby the mutual information; indeed, the estimates of DPWS and
TI-PWS are higher than that of RR-PWS. For brute-force DPWS, the error
decreases as we increase the number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
of input trajectories per output trajectory used to estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>.
Similarly, for TI-PWS the error decreases as we use more MCMC samples
for the marginalization scheme. For the RR-PWS, however, already for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">M=128</annotation></semantics></math>
the estimate has converged; we verified that a further increase of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
does not change the results.</p>
<p>We also find excellent agreement between the RR-PWS estimate and the
approximate result of Duso and Zechner <span class="citation"
data-cites="2019.Duso">Â [<a href="#ref-2019.Duso"
role="doc-biblioref">9</a>]</span>. Only very small deviations are
visible in <a href="#fig:gene-expr">Fig. gene-expr</a>. These deviations
are mostly caused by the different choice for the initial conditions. In
RR-PWS, the initial conditions are drawn from the stationary
distribution, while in the Duso scheme they are fixed, such that the
mutual information computed with RR-PWS is finite while that computed
with the Duso scheme is zero. Yet, as the trajectory duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
increases, the Duso estimate slowly â€œcatches upâ€ with the RR-PWS
result.</p>
<p><a href="#fig:gene-expr">Fig. gene-expr</a> also shows that although
the Gaussian model matches the PWS result for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">T=0</annotation></semantics></math>,
it systematically underestimates the mutual information for trajectories
of finite duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">T&gt;0</annotation></semantics></math>.
Interestingly, this is not a consequence of small copy-number
fluctuations: increasing the average copy number does not significantly
improve the Gaussian estimate.<a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<figure id="fig:timing">
<img src="../images/Timing.svg"  />
<figcaption>Comparing estimation bias for the different PWS variants in
relation to their CPU time requirements. Each dot represents a single
mutual information estimate with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>10</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">N=10^4</annotation></semantics></math>
samples for output trajectories of duration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">T=5</annotation></semantics></math>.
Almost all the CPU time of a PWS estimate is spent on the computation of
the marginal probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>.
The bias of the marginal probability estimate can be reduced by using a
larger number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
of sampled input trajectories to compute the marginalization integral,
which also increases the required CPU time. The RR-PWS estimate
converges much faster than the estimate of DPWS and TI-PWS. For DPWS and
TI-PWS, the dots represents estimates ranging from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">M=2^5</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">M=2^{14}</annotation></semantics></math>,
for RR-PWS ranging from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">M=2^3</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">M=2^{10}</annotation></semantics></math>.
As the baseline of zero bias we use the converged result from the RR-PWS
estimates.</figcaption>
</figure>
<p>The different approaches for computing the marginal probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>
lead to different computational efficiencies of the respective PWS
schemes. In <a href="#fig:timing">Fig. timing</a>, as a benchmark, we
show the magnitude of the error of the different PWS estimates in
relation to the required CPU time. Indeed, as expected, the computation
of the marginal probability poses problems for long trajectories when
using the brute force DPWS scheme. More interestingly, while TI-PWS
improves the estimate of the mutual information, the improvement is not
dramatic. Unlike the brute-force scheme, thermodynamic integration does
make it possible to generate input trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
that are correlated with the output trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>,
but it still overestimates the mutual information for long trajectories
unless a very large number of MCMC samples are used.</p>
<p>The RR-PWS implementation evidently outperforms the other estimates
for this system. The regular resampling steps ensure that we mostly
sample input trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
with non-vanishing likelihood
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}|\mathbfit{s}]</annotation></semantics></math>,
thereby avoiding the sampling problem from DPWS. Moreover, sequential
Monte Carlo techniques such as RR-PWS and FFS <span class="citation"
data-cites="2006.Allen">Â [<a href="#ref-2006.Allen"
role="doc-biblioref">14</a>]</span> have a considerable advantage over
MCMC techniques in trajectory sampling. With MCMC path sampling, we
frequently make small changes to an existing trajectory such that the
system moves slowly in path space, leading to poor statistics. In
contrast, in RR-PWS we generate new trajectories from scratch, segment
by segment, and these explore the trajectory space much faster.</p>
<h2 id="discussion">Discussion</h2>
<p>Aside from Direct PWS introduced in <a href="#ch:dpws">Ch. dpws</a>,
we developed two additional variants of PWS, capitalizing on the
connection between information theory and statistical physics.
Specifically, the computation of the mutual information requires the
evaluation of the marginal probability of individual output trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]</annotation></semantics></math>.
This corresponds to the computation of a partition function in
statistical physics,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mo>âˆ«</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}]=\int \mathcal{P}[\mathbfit{s}]\,\mathcal{P}[\mathbfit{s}]\mathcal{P}[\mathbfit{x}|\mathbfit{s}]</annotation></semantics></math>.
RR-PWS and TI-PWS are based on techniques from polymer and rare-event
simulations to make the computation of the marginal trajectory
probability more efficient.</p>
<p>The different PWS variants share some characteristics yet also differ
in others. DPWS and RR-PWS are static Monte Carlo schemes in which the
trajectories are generated independently from the previous ones. These
methods are similar to static polymer sampling schemes like PERM <span
class="citation" data-cites="1997.Grassberger">Â [<a
href="#ref-1997.Grassberger" role="doc-biblioref">2</a>]</span> and
rare-event methods like DFFS or BG-FFS <span class="citation"
data-cites="2006.Allen">Â [<a href="#ref-2006.Allen"
role="doc-biblioref">14</a>]</span>. In contrast, TI-PWS is a dynamic
Monte Carlo scheme, where a new trajectory is generated from the
previous trajectory. In this regard, this method is similar to the CBMC
scheme for polymer simulations <span class="citation"
data-cites="1992.Siepmann">Â [<a href="#ref-1992.Siepmann"
role="doc-biblioref">34</a>]</span> and the TPS <span class="citation"
data-cites="2002.Bolhuis">Â [<a href="#ref-2002.Bolhuis"
role="doc-biblioref">7</a>]</span>, TIS <span class="citation"
data-cites="2003.Erp">Â [<a href="#ref-2003.Erp"
role="doc-biblioref">35</a>]</span>, and RB-FFS <span class="citation"
data-cites="2006.Allen">Â [<a href="#ref-2006.Allen"
role="doc-biblioref">14</a>]</span> schemes to harvest transition paths.
The benefit of static schemes is that the newly generated trajectories
are uncorrelated from the previous ones, which means that they are less
likely to get stuck in certain regions of path space. Concomitantly,
they tend to diffuse faster through the configuration space. Indeed,
TI-PWS suffers from a problem that is also often encountered in TPS or
TIS, which is that the middle sections of the trajectories move only
slowly in their perpendicular direction. Tricks that have been applied
to TPS and TIS to solve this problem, such as parallel tempering, could
also be of use here <span class="citation" data-cites="2001.Vlugt">Â [<a
href="#ref-2001.Vlugt" role="doc-biblioref">36</a>]</span>.</p>
<p>Another distinction is that RR-PWS generates all the trajectories in
the ensemble simultaneously yet segment by segment, like DFFS, while
DPWS and TI-PWS generate only one full trajectory at the time, similar
to RB-FFS, BG-FFS, and also TPS and TIS. Consequently, RR-PWS, like
DFFS, faces the risk of <em>genetic drift</em>, which means that, after
sufficiently many resampling steps, most paths of the ensemble will
originate from the same initial seed. Thus, when continuing to sample
new segments, the old segments that are far in the past become
essentially fixed, which makes it possible to miss important paths in
the RR-PWS sampling procedure. As in DFFS, the risk of genetic drift in
RR-PWS can be mitigated by increasing the initial number of path
segments. Although we did not employ this trick here, we found that
RR-PWS was by far the most powerful scheme of the three variants
studied.</p>
<p>Nonetheless, we expect that DPWS and TI-PWS become more efficient in
systems that respond to the input signal with a significant delay
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï„</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>.
In these cases, the weight of a particular output trajectory depends on
the degree to which the dynamics of the output trajectory correlates
with the dynamics of the intput trajectory a time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï„</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
earlier. Because in RR-PWS a new segment of an output trajectory is
generated based on the corresponding segment of the input trajectory
that spans the same time-interval, it may therefore miss these
correlations between the dynamics of the output and that of the input a
time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ï„</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
earlier. In contrast, DPWS and TI-PWS generate full trajectories one at
the time, and are therefore more likely to capture these correlations.
Also the machine-learning based approach for determining the optimal
importance sampling distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">q[\mathbfit{s}|\mathbfit{x}]</annotation></semantics></math>
presented in <a href="#ch:ml-pws">Ch. ml-pws</a> (<a
href="#sec:ml_variational">Sec. ml_variational</a>) is likely to prove
useful in these scenarios with complex temporal dependences between the
input and output trajectories.</p>
<h2 id="supplementary-information">Supplementary Information</h2>
<h3 id="sec:gaussian-covariance"
id="gaussian-approximation-of-the-linear-system">Gaussian Approximation
of the Linear System </h3>
<p>We derive the Gaussian approximation of the simple reaction system
used in <a href="#sec:pws_variants_benchmark">Sec.
pws_variants_benchmark</a>. We recall the elementary biochemical
reaction motif consisting of four reactions </p>
<div id="eq:reaction-scheme">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">0 â†’ S</mtext><mo>,</mo><mspace width="1.0em"></mspace><mtext mathvariant="normal">S â†’ 0</mtext><mo>,</mo><mspace width="1.0em"></mspace><mtext mathvariant="normal">S â†’ S + X</mtext><mo>,</mo><mspace width="1.0em"></mspace><mtext mathvariant="normal">X â†’ 0</mtext></mrow><annotation encoding="application/x-tex">\text{0  â†’  S}, \quad
    \text{S  â†’  0}, \quad
    \text{S  â†’  S + X}, \quad
    \text{X  â†’  0}
    \label{eq:reaction-scheme}</annotation></semantics></math>
</div>
<p> with input
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
and output
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>.
This reaction motif is a simple model for gene expression, where the
rate of production of a protein
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
is controlled by a transcription factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>,
and X itself has a characteristic decay rate. The dynamics of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
are given by a constant birth rate and a constant (per-molecule) decay
rate.</p>
<p>We compute the covariance functions of this model which are then used
to derive Gaussian signal statistics, and allow us to compute the
Gaussian information rate. Specifically, we assume that the process is
sampled at a sampling rate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î½</mi><annotation encoding="application/x-tex">\nu</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_1,\ldots,S_n</annotation></semantics></math>
being the sequence of sampled inputs and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_1,\ldots,X_n</annotation></semantics></math>
being the sequence of outputs in time. We can describe the dynamics of
the input and output as fluctuations around the mean, i.e. we write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î´</mi><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><msub><mi>S</mi><mi>i</mi></msub><mo>âˆ’</mo><mo stretchy="false" form="prefix">âŸ¨</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">âŸ©</mo></mrow><annotation encoding="application/x-tex">\delta S_i = S_i - \langle S_i \rangle</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î´</mi><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><msub><mi>X</mi><mi>i</mi></msub><mo>âˆ’</mo><mo stretchy="false" form="prefix">âŸ¨</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">âŸ©</mo></mrow><annotation encoding="application/x-tex">\delta X_i = X_i - \langle X_i \rangle</annotation></semantics></math>.
In the limit of large copy numbers, due to the central limit theorem,
the distribution of these fluctuations become Gaussian <span
class="citation" data-cites="2009.Gardiner">Â [<a
href="#ref-2009.Gardiner" role="doc-biblioref">37</a>]</span>.</p>
<p>In particular, let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>Î´</mi><msub><mi>S</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>Î´</mi><msub><mi>S</mi><mi>n</mi></msub><mo>,</mo><mi>Î´</mi><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>Î´</mi><msub><mi>X</mi><mi>n</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\mathbfit{Z}=(\delta S_1,\ldots,\delta S_n, \delta X_1,\ldots,\delta X_n)^T</annotation></semantics></math>
be the concatenation of the input and output sequences. Then, the
distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’</mi><annotation encoding="application/x-tex">\mathbfit{Z}</annotation></semantics></math>
is multivariate normal, i.e., </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">P</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo>=</mo><mi>ğ’›</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mo stretchy="false" form="prefix">(</mo><mn>2</mn><mi>Ï€</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mn>2</mn><mi>n</mi></mrow></msup><mo stretchy="false" form="prefix">|</mo><mi mathvariant="normal">Î£</mi><mo stretchy="false" form="prefix">|</mo></mrow></msqrt></mfrac><msup><mi>e</mi><mrow><mi>âˆ’</mi><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false" form="prefix">(</mo><msup><mi>ğ’›</mi><mi>T</mi></msup><msup><mi mathvariant="normal">Î£</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mi>ğ’›</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\mathrm{P}(\mathbfit{Z}=\mathbfit{z}) = \frac{1}{\sqrt{(2\pi)^{2n}|\Sigma|}} e^{-\frac{1}{2}(\mathbfit{z}^T \Sigma^{-1} \mathbfit{z})}</annotation></semantics></math>
<p> where the covariance Matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î£</mi><mo>âˆˆ</mo><msup><mi>â„</mi><mrow><mn>2</mn><mi>n</mi><mo>Ã—</mo><mn>2</mn><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\Sigma\in\mathbb{R}^{2n\times 2n}</annotation></semantics></math>
has the following block structure </p>
<div id="eq:cov_z">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î£</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi mathvariant="normal">Î£</mi><mrow><mi>S</mi><mi>S</mi></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi mathvariant="normal">Î£</mi><mrow><mi>X</mi><mi>S</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi mathvariant="normal">Î£</mi><mrow><mi>S</mi><mi>X</mi></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi mathvariant="normal">Î£</mi><mrow><mi>X</mi><mi>X</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">\Sigma = \left( \begin{array}{cc}
        \Sigma_{SS} &amp; \Sigma_{XS} \\
        \Sigma_{SX} &amp; \Sigma_{XX}
    \end{array} \right)\,.
    \label{eq:cov_z}</annotation></semantics></math>
</div>
<p> Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Î£</mi><mrow><mi>S</mi><mi>S</mi></mrow></msub><annotation encoding="application/x-tex">\Sigma_{SS}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Î£</mi><mrow><mi>X</mi><mi>X</mi></mrow></msub><annotation encoding="application/x-tex">\Sigma_{XX}</annotation></semantics></math>
are the (auto-)covariance matrices of the input and the output,
respectively, whereas
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Î£</mi><mrow><mi>S</mi><mi>X</mi></mrow></msub><mo>=</mo><msubsup><mi mathvariant="normal">Î£</mi><mrow><mi>X</mi><mi>S</mi></mrow><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">\Sigma_{SX}=\Sigma^T_{XS}</annotation></semantics></math>
contain the cross-covariances. The matrix elements are given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">Î£</mi><mrow><mi>A</mi><mi>B</mi></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msubsup><mo>=</mo><mo stretchy="false" form="prefix">âŸ¨</mo><mi>Î´</mi><msub><mi>A</mi><mi>i</mi></msub><mi>Î´</mi><msub><mi>B</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">âŸ©</mo><mo>=</mo><msub><mi>C</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>âˆ’</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Sigma^{ij}_{AB} = \langle \delta A_i \delta B_j \rangle = C_{AB}(t_i - t_j)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">C_{AB}(t)</annotation></semantics></math>
denote the (cross-)covariance functions and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_1,\ldots,t_n</annotation></semantics></math>
are the sampling times. Thus, the full statistics of the trajectories
are determined from the covariance functions.</p>
<p>Since the reaction scheme in <a
href="#eq:reaction-scheme">eq:reaction-scheme</a> features only
first-order reactions, the covariance functions can be calculated
explicitly using the regression theorem <span class="citation"
data-cites="2006.Warren 2009.Gardiner">Â [<a href="#ref-2009.Gardiner"
role="doc-biblioref">37</a>,<a href="#ref-2006.Warren"
role="doc-biblioref">38</a>]</span>. For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>â‰¥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t\geq 0</annotation></semantics></math>,
we obtain the following expressions for the covariance functions: </p>
<div id="eq:c_ss">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>C</mi><mrow><mi>S</mi><mi>S</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><msubsup><mi>Ïƒ</mi><mrow><mi>S</mi><mi>S</mi></mrow><mn>2</mn></msubsup><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>Î»</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>C</mi><mrow><mi>S</mi><mi>X</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>Ï</mi><msubsup><mi>Ïƒ</mi><mrow><mi>S</mi><mi>S</mi></mrow><mn>2</mn></msubsup><mi>t</mi><mspace width="0.222em"></mspace><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">x</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="prefix">(</mo><mi>Î»</mi><mo>âˆ’</mo><mi>Î¼</mi><mo stretchy="false" form="postfix">)</mo><mi>t</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>Î»</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msubsup><mi>Ïƒ</mi><mrow><mi>S</mi><mi>X</mi></mrow><mn>2</mn></msubsup><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>Î¼</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>C</mi><mrow><mi>X</mi><mi>S</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><msubsup><mi>Ïƒ</mi><mrow><mi>S</mi><mi>X</mi></mrow><mn>2</mn></msubsup><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>Î»</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>C</mi><mrow><mi>X</mi><mi>X</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>Ï</mi><msubsup><mi>Ïƒ</mi><mrow><mi>S</mi><mi>X</mi></mrow><mn>2</mn></msubsup><mi>t</mi><mspace width="0.222em"></mspace><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">x</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="prefix">(</mo><mi>Î»</mi><mo>âˆ’</mo><mi>Î¼</mi><mo stretchy="false" form="postfix">)</mo><mi>t</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>Î»</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msubsup><mi>Ïƒ</mi><mrow><mi>X</mi><mi>X</mi></mrow><mn>2</mn></msubsup><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>Î¼</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.167em"></mspace><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \label{eq:c_ss} C_{SS}(t) &amp;= \sigma^2_{SS} \exp(-\lambda t) \\
    \label{eq:c_sx} C_{SX}(t) &amp;= \rho\sigma^2_{SS}t\ \mathrm{exprel}[(\lambda - \mu) t]\ \exp(-\lambda t) + \sigma^2_{SX} \exp(-\mu t) \\
    \label{eq:c_xs} C_{XS}(t) &amp;= \sigma^2_{SX} \exp(-\lambda t) \\
   \label{eq:c_xx} C_{XX}(t) &amp;= \rho \sigma^2_{SX} t\ \mathrm{exprel}[(\lambda - \mu) t]\ \exp(-\lambda t) + \sigma^2_{XX} \exp(-\mu t)\,.
\end{aligned}</annotation></semantics></math>
</div>
<p> In the expressions above we used the relative exponential function
</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">x</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mfrac><mrow><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>âˆ’</mo><mn>1</mn></mrow><mi>x</mi></mfrac><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>x</mi><mo>â‰ </mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>1</mn><mo>,</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>x</mi><mo>=</mo><mn>0</mn></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\mathrm{exprel}(x) = \begin{cases}
                    \frac{{\exp(x) - 1}}{{x}}, &amp; \text{if } x \neq 0 \\
                    1, &amp; \text{if } x = 0
                  \end{cases}</annotation></semantics></math>
<p> and the point (co-)variances </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msubsup><mi>Ïƒ</mi><mrow><mi>S</mi><mi>S</mi></mrow><mn>2</mn></msubsup></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mi>Îº</mi><mi>Î»</mi></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msubsup><mi>Ïƒ</mi><mrow><mi>S</mi><mi>X</mi></mrow><mn>2</mn></msubsup></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mrow><mi>Ï</mi><msubsup><mi>Ïƒ</mi><mrow><mi>S</mi><mi>S</mi></mrow><mn>2</mn></msubsup></mrow><mrow><mi>Î»</mi><mo>+</mo><mi>Î¼</mi></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msubsup><mi>Ïƒ</mi><mrow><mi>X</mi><mi>X</mi></mrow><mn>2</mn></msubsup></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mi>Ï</mi><mi>Î¼</mi></mfrac><mo stretchy="false" form="prefix">(</mo><msubsup><mi>Ïƒ</mi><mrow><mi>S</mi><mi>S</mi></mrow><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>Ïƒ</mi><mrow><mi>S</mi><mi>X</mi></mrow><mn>2</mn></msubsup><mo stretchy="false" form="postfix">)</mo><mspace width="0.167em"></mspace><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \sigma^2_{SS} &amp;= \frac{\kappa}{\lambda} \\
    \sigma^2_{SX} &amp;= \frac{\rho \sigma^2_{SS}}{\lambda + \mu} \\
    \sigma^2_{XX} &amp;= \frac{\rho}{\mu} (\sigma^2_{SS} + \sigma^2_{SX})\,.
\end{aligned}</annotation></semantics></math>
<p> Because the process is stationary, the values of the covariance
functions for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t&lt;0</annotation></semantics></math>
can be obtained by applying the symmetry relation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>C</mi><mrow><mi>B</mi><mi>A</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">C_{AB}(t) = C_{BA}(-t)</annotation></semantics></math>.</p>
<p>Now, we can directly compute the mutual information from the
covariances. Using <a href="#eq:c_ss">eq:c_ss</a>, <a
href="#eq:c_sx">eq:c_sx</a>, <a href="#eq:c_xs">eq:c_xs</a> and <a
href="#eq:c_xx">eq:c_xx</a> we obtain the matrix elements of the joint
covariance matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Î£</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
defined in <a href="#eq:cov_z">eq:cov_z</a> and then the mutual
information is given by the expression </p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’®</mi><mo>,</mo><mi>ğ’³</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mi>ln</mi><mo>&#8289;</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mo stretchy="false" form="prefix">|</mo><msub><mi mathvariant="normal">Î£</mi><mrow><mi>S</mi><mi>S</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><mo stretchy="false" form="prefix">|</mo><msub><mi mathvariant="normal">Î£</mi><mrow><mi>X</mi><mi>X</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo></mrow><mrow><mo stretchy="false" form="prefix">|</mo><mi mathvariant="normal">Î£</mi><mo stretchy="false" form="prefix">|</mo></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">I(\mathcal{S}, \mathcal{X}) = \frac{1}{2} \ln \left( \frac{|\Sigma_{SS}||\Sigma_{XX}|}{|\Sigma|} \right).</annotation></semantics></math>
<p> Note, that for discretized trajectories of length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Î£</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
has dimensions of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>Ã—</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n\times 2n</annotation></semantics></math>.
Thus, the computation of the trajectory mutual information requires the
computation of a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>Ã—</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n\times 2n</annotation></semantics></math>
matrix, which can be computationally challenging for long trajectories
(large
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>).
In <a href="#ch:notes-gaussian">Ch. notes-gaussian</a> of this thesis,
we discuss some techniques to considerably accelerate the computation of
the mutual information.</p>
<p>Using spectral analysis, Tostevin and Wolde <span class="citation"
data-cites="2010.Tostevin">Â [<a href="#ref-2010.Tostevin"
role="doc-biblioref">39</a>]</span> were able to derive an analytical
expression for the Gaussian mutual information rate of this model in the
continuous-time limit, given by </p>
<div id="eq:spectral_tostevin_gaussian">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’®</mi><mo>,</mo><mi>ğ’³</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mi>Î»</mi><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">[</mo><msqrt><mrow><mn>1</mn><mo>+</mo><mfrac><mi>Ï</mi><mi>Î»</mi></mfrac></mrow></msqrt><mo>âˆ’</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mspace width="0.167em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">R(\mathcal{S}, \mathcal{X}) = \frac{\lambda}{2}\left[ \sqrt{1 + \frac{\rho}{\lambda}} - 1 \right] \,.
    \label{eq:spectral_tostevin_gaussian}</annotation></semantics></math>
</div>
<p> The information rate of the discretely sampled process converges to
this value as the sampling rate approaches infinity <span
class="citation" data-cites="2010.Tostevin">Â [<a
href="#ref-2010.Tostevin" role="doc-biblioref">39</a>]</span>. Notably
however, the model corresponding to <a
href="#eq:spectral_tostevin_gaussian">eq:spectral_tostevin_gaussian</a>
is a continuum description that assumes Gaussian statistics; indeed,
this rate deviates from the mutual information rate of the exact model
that is described by the chemical master equation, even in the limit of
large copy numbers <span class="citation" data-cites="2023.Moor">Â [<a
href="#ref-2023.Moor" role="doc-biblioref">40</a>]</span>. This finding
is also further discussed in <a href="#ch:lna_vs_pws">Ch. lna_vs_pws</a>
(<a href="#sec:linsys">Sec. linsys</a>).</p>
<h2 class="unnumbered" id="bibliography">References</h2>
<div id="refs" class="references csl-bib-body" data-entry-spacing="0"
role="list">
<div id="ref-1990.Siepmann" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">J.
I. Siepmann, <a href="https://doi.org/10.1080/00268979000101591"><span
class="nocase">A method for the direct calculation of chemical
potentials for dense chain systems</span></a>, Molecular Physics
<strong>70</strong>, 1145 (1990).</div>
</div>
<div id="ref-1997.Grassberger" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">P.
Grassberger, <a href="https://doi.org/10.1103/physreve.56.3682"><span
class="nocase">Pruned-enriched Rosenbluth method: Simulations of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¸</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
polymers of chain length up to 1 000 000</span></a>, Physical Review E
<strong>56</strong>, 3682 (1997).</div>
</div>
<div id="ref-2002.Frenkel" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">D.
Frenkel and B. Smit, <em><a
href="https://doi.org/10.1016/b978-0-12-267351-1.x5000-7"><span>Understanding
Molecular Simulation</span></a></em>, 2nd ed. (Academic Press, San
Diego, 2002).</div>
</div>
<div id="ref-1984.Frenkel" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">D.
Frenkel and A. J. C. Ladd, <a
href="https://doi.org/10.1063/1.448024"><span class="nocase">New Monte
Carlo method to compute the free energy of arbitrary solids. Application
to the fcc and hcp phases of hard spheres</span></a>, The Journal of
Chemical Physics <strong>81</strong>, 3188 (1984).</div>
</div>
<div id="ref-1998.Gelman" class="csl-entry" role="listitem">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">A.
Gelman and X.-L. Meng, <a
href="https://doi.org/10.1214/ss/1028905934"><span
class="nocase">Simulating normalizing constants: from importance
sampling to bridge sampling to path sampling</span></a>, Statistical
Science <strong>13</strong>, 163 (1998).</div>
</div>
<div id="ref-2001.Neal" class="csl-entry" role="listitem">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">R.
M. Neal, <a href="https://doi.org/10.1023/a:1008923215028"><span
class="nocase">Annealed importance sampling</span></a>, Statistics and
Computing <strong>11</strong>, 125 (2001).</div>
</div>
<div id="ref-2002.Bolhuis" class="csl-entry" role="listitem">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">P.
G. Bolhuis, D. Chandler, C. Dellago, and P. L. Geissler, <a
href="https://doi.org/10.1146/annurev.physchem.53.082301.113146"><span
class="nocase">TRANSITION PATH SAMPLING: Throwing Ropes Over Rough
Mountain Passes, in the Dark</span></a>, Annual Review of Physical
Chemistry <strong>53</strong>, 291 (2002).</div>
</div>
<div id="ref-2009.Tostevin" class="csl-entry" role="listitem">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">F.
Tostevin and P. R. ten Wolde, <a
href="https://doi.org/10.1103/physrevlett.102.218101"><span
class="nocase">Mutual Information between Input and Output Trajectories
of Biochemical Networks</span></a>, Physical Review Letters
<strong>102</strong>, 218101 (2009).</div>
</div>
<div id="ref-2019.Duso" class="csl-entry" role="listitem">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">L.
Duso and C. Zechner, <em><a
href="https://doi.org/10.1109/CDC40024.2019.9029316">Path Mutual
Information for a Class of Biochemical Reaction Networks</a></em>, in
<em>2019 IEEE 58th Conference on Decision and Control (CDC)</em> (2019),
pp. 6610â€“6615.</div>
</div>
<div id="ref-1994.Mueller" class="csl-entry" role="listitem">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">M.
MÃ¼ller and W. Paul, <a href="https://doi.org/10.1063/1.466937"><span
class="nocase">Measuring the chemical potential of polymer solutions and
melts in computer simulations</span></a>, The Journal of Chemical
Physics <strong>100</strong>, 719 (1994).</div>
</div>
<div id="ref-1955.Rosenbluth" class="csl-entry" role="listitem">
<div class="csl-left-margin">[11] </div><div class="csl-right-inline">M.
N. Rosenbluth and A. W. Rosenbluth, <a
href="https://doi.org/10.1063/1.1741967"><span class="nocase">Monte
Carlo Calculation of the Average Extension of Molecular
Chains</span></a>, The Journal of Chemical Physics <strong>23</strong>,
356 (1955).</div>
</div>
<div id="ref-1993.Gordon" class="csl-entry" role="listitem">
<div class="csl-left-margin">[12] </div><div class="csl-right-inline">N.
J. Gordon, D. J. Salmond, and A. F. M. Smith, <a
href="https://doi.org/10.1049/ip-f-2.1993.0015"><span
class="nocase">Novel approach to nonlinear/non-Gaussian Bayesian state
estimation</span></a>, IEE Proceedings F Radar and Signal Processing
<strong>140</strong>, 107 (1993).</div>
</div>
<div id="ref-2004.Prellberg" class="csl-entry" role="listitem">
<div class="csl-left-margin">[13] </div><div class="csl-right-inline">T.
Prellberg and J. Krawczyk, <a
href="https://doi.org/10.1103/physrevlett.92.120602"><span
class="nocase">Flat Histogram Version of the Pruned and Enriched
Rosenbluth Method</span></a>, Physical Review Letters
<strong>92</strong>, 120602 (2004).</div>
</div>
<div id="ref-2006.Allen" class="csl-entry" role="listitem">
<div class="csl-left-margin">[14] </div><div class="csl-right-inline">R.
J. Allen, D. Frenkel, and P. R. ten Wolde, <a
href="https://doi.org/10.1063/1.2140273"><span class="nocase">Simulating
rare events in equilibrium or nonequilibrium stochastic
systems</span></a>, The Journal of Chemical Physics
<strong>124</strong>, 024102 (2006).</div>
</div>
<div id="ref-2012.Becker" class="csl-entry" role="listitem">
<div class="csl-left-margin">[15] </div><div class="csl-right-inline">N.
B. Becker, R. J. Allen, and P. R. ten Wolde, <a
href="https://doi.org/10.1063/1.4704810"><span
class="nocase">Non-stationary forward flux sampling</span></a>, The
Journal of Chemical Physics <strong>136</strong>, 174118 (2012).</div>
</div>
<div id="ref-1997.Moral" class="csl-entry" role="listitem">
<div class="csl-left-margin">[16] </div><div class="csl-right-inline">P.
Del Moral, <a href="https://doi.org/10.1016/s0764-4442(97)84778-7"><span
class="nocase">Nonlinear filtering: Interacting particle
resolution</span></a>, Comptes Rendus de lâ€™AcadÃ©mie Des Sciences -
Series I - Mathematics <strong>325</strong>, 653 (1997).</div>
</div>
<div id="ref-1992.Smith" class="csl-entry" role="listitem">
<div class="csl-left-margin">[17] </div><div class="csl-right-inline">A.
F. M. Smith and A. E. Gelfand, <a
href="https://doi.org/10.2307/2684170"><span class="nocase">Bayesian
Statistics without Tears: A Sampling-Resampling Perspective</span></a>,
The American Statistician <strong>46</strong>, 84 (1992).</div>
</div>
<div id="ref-2017.Martino" class="csl-entry" role="listitem">
<div class="csl-left-margin">[18] </div><div class="csl-right-inline">L.
Martino, V. Elvira, and F. Louzada, <a
href="https://doi.org/10.1016/j.sigpro.2016.08.025"><span
class="nocase">Effective sample size for importance sampling based on
discrepancy measures</span></a>, Signal Processing <strong>131</strong>,
386 (2017).</div>
</div>
<div id="ref-2011.Doucet" class="csl-entry" role="listitem">
<div class="csl-left-margin">[19] </div><div class="csl-right-inline">A.
Doucet and A. M. Johansen, <em><span class="nocase">A tutorial on
particle filtering and smoothing: fifteen years later</span></em>, in
<em>Oxford Handbook of Nonlinear Filtering</em>, edited by D. Crisan and
B. Rozovskii (Oxford University Press, 2011).</div>
</div>
<div id="ref-1953.Metropolis" class="csl-entry" role="listitem">
<div class="csl-left-margin">[20] </div><div class="csl-right-inline">N.
Metropolis, A. W. Rosenbluth, M. N. Rosenbluth, A. H. Teller, and E.
Teller, <a href="https://doi.org/10.1063/1.1699114"><span
class="nocase">Equation of State Calculations by Fast Computing
Machines</span></a>, The Journal of Chemical Physics
<strong>21</strong>, 1087 (1953).</div>
</div>
<div id="ref-1998a.Dellago" class="csl-entry" role="listitem">
<div class="csl-left-margin">[21] </div><div class="csl-right-inline">C.
Dellago, P. G. Bolhuis, and D. Chandler, <a
href="https://doi.org/10.1063/1.476378"><span class="nocase">Efficient
transition path sampling: Application to Lennard-Jones cluster
rearrangements</span></a>, The Journal of Chemical Physics
<strong>108</strong>, 9236 (1998).</div>
</div>
<div id="ref-2009.Hobolth" class="csl-entry" role="listitem">
<div class="csl-left-margin">[22] </div><div class="csl-right-inline">A.
Hobolth and E. A. Stone, <a
href="https://doi.org/10.1214/09-aoas247"><span
class="nocase">Simulation from endpoint-conditioned, continuous-time
Markov chains on a finite state space, with applications to molecular
evolution</span></a>, The Annals of Applied Statistics
<strong>3</strong>, 1204 (2009).</div>
</div>
<div id="ref-2017.Meulen" class="csl-entry" role="listitem">
<div class="csl-left-margin">[23] </div><div class="csl-right-inline">F.
van der Meulen and M. Schauer, <a
href="https://doi.org/10.1214/17-ejs1290"><span class="nocase">Bayesian
estimation of discretely observed multi-dimensional diffusion processes
using guided proposals</span></a>, Electronic Journal of Statistics
<strong>11</strong>, 2358 (2017).</div>
</div>
<div id="ref-2015.Golightly" class="csl-entry" role="listitem">
<div class="csl-left-margin">[24] </div><div class="csl-right-inline">A.
Golightly and D. J. Wilkinson, <a
href="https://doi.org/10.1515/sagmb-2014-0070"><span
class="nocase">Bayesian inference for Markov jump processes with
informative observations</span></a>, Statistical Applications in
Genetics and Molecular Biology <strong>14</strong>, 169 (2015).</div>
</div>
<div id="ref-2019.Gillespie" class="csl-entry" role="listitem">
<div class="csl-left-margin">[25] </div><div class="csl-right-inline">C.
S. Gillespie and A. Golightly, <a
href="https://doi.org/10.1063/1.5090979"><span class="nocase">Guided
proposals for efficient weighted stochastic simulation</span></a>, The
Journal of Chemical Physics <strong>150</strong>, 224103 (2019).</div>
</div>
<div id="ref-2000.Crooks" class="csl-entry" role="listitem">
<div class="csl-left-margin">[26] </div><div class="csl-right-inline">G.
E. Crooks, <a href="https://doi.org/10.1103/physreve.61.2361"><span
class="nocase">Path-ensemble averages in systems driven far from
equilibrium</span></a>, Physical Review E <strong>61</strong>, 2361
(2000).</div>
</div>
<div id="ref-2010.Andrieu" class="csl-entry" role="listitem">
<div class="csl-left-margin">[27] </div><div class="csl-right-inline">C.
Andrieu, A. Doucet, and R. Holenstein, <a
href="https://doi.org/10.1111/j.1467-9868.2009.00736.x"><span
class="nocase">Particle Markov chain Monte Carlo methods</span></a>,
Journal of the Royal Statistical Society: Series B (Statistical
Methodology) <strong>72</strong>, 269 (2010).</div>
</div>
<div id="ref-2013.Rao" class="csl-entry" role="listitem">
<div class="csl-left-margin">[28] </div><div class="csl-right-inline">V.
Rao and Y. W. Teh, <a
href="http://jmlr.org/papers/v14/rao13a.html"><span class="nocase">Fast
MCMC sampling for Markov jump processes and extensions</span></a>,
Journal of Machine Learning Research <strong>14</strong>, 3295
(2013).</div>
</div>
<div id="ref-2017.Bezanson" class="csl-entry" role="listitem">
<div class="csl-left-margin">[29] </div><div class="csl-right-inline">J.
Bezanson, A. Edelman, S. Karpinski, and V. B. Shah, <a
href="https://doi.org/10.1137/141000671"><span class="nocase">Julia: A
Fresh Approach to Numerical Computing</span></a>, SIAM Review
<strong>59</strong>, 65 (2017).</div>
</div>
<div id="ref-manuel_reinhardt_2021_6334035" class="csl-entry"
role="listitem">
<div class="csl-left-margin">[30] </div><div class="csl-right-inline">M.
Reinhardt, <a href="https://doi.org/10.5281/zenodo.6334035"><span
class="nocase">PathWeightSampling.jl (v0.1.0)</span></a>, (2021).</div>
</div>
<div id="ref-pws_github" class="csl-entry" role="listitem">
<div class="csl-left-margin">[31] </div><div class="csl-right-inline">M.
Reinhardt, <a
href="https://github.com/manuel-rhdt/PathWeightSampling.jl"><span
class="nocase">manuel-rhdt/PathWeightSampling.jl</span></a>,
(2024).</div>
</div>
<div id="ref-2017.Rackauckas" class="csl-entry" role="listitem">
<div class="csl-left-margin">[32] </div><div class="csl-right-inline">C.
Rackauckas and Q. Nie, <a href="https://doi.org/10.5334/jors.151"><span
class="nocase">DifferentialEquations.jl â€“ A Performant and Feature-Rich
Ecosystem for Solving Differential Equations in Julia</span></a>,
Journal of Open Research Software <strong>5</strong>, 15 (2017).</div>
</div>
<div id="ref-2024.Moor" class="csl-entry" role="listitem">
<div class="csl-left-margin">[33] </div><div
class="csl-right-inline">A.-L. Moor, A. Tjalma, M. Reinhardt, P. R. ten
Wolde, and C. Zechner, <em>Reaction-Based Information Processing in
Biochemical Networks</em>, (unpublished).</div>
</div>
<div id="ref-1992.Siepmann" class="csl-entry" role="listitem">
<div class="csl-left-margin">[34] </div><div class="csl-right-inline">J.
I. Siepmann and D. Frenkel, <a
href="https://doi.org/10.1080/00268979200100061"><span
class="nocase">Configurational bias Monte Carlo: a new sampling scheme
for flexible chains</span></a>, Molecular Physics <strong>75</strong>,
59 (1992).</div>
</div>
<div id="ref-2003.Erp" class="csl-entry" role="listitem">
<div class="csl-left-margin">[35] </div><div class="csl-right-inline">T.
S. van Erp, D. Moroni, and P. G. Bolhuis, <a
href="https://doi.org/10.1063/1.1562614"><span class="nocase">A novel
path sampling method for the calculation of rate constants</span></a>,
The Journal of Chemical Physics <strong>118</strong>, 7762 (2003).</div>
</div>
<div id="ref-2001.Vlugt" class="csl-entry" role="listitem">
<div class="csl-left-margin">[36] </div><div class="csl-right-inline">T.
J. H. Vlugt and B. Smit, <a
href="https://doi.org/10.1039/b009865p"><span class="nocase">On the
efficient sampling of pathways in the transition path
ensemble</span></a>, PhysChemComm <strong>4</strong>, 11 (2001).</div>
</div>
<div id="ref-2009.Gardiner" class="csl-entry" role="listitem">
<div class="csl-left-margin">[37] </div><div class="csl-right-inline">C.
Gardiner, <em><span class="nocase">Handbook of Stochastic
Methods</span></em>, 4th ed. (Springer-Verlag, Berlin Heidelberg,
2009).</div>
</div>
<div id="ref-2006.Warren" class="csl-entry" role="listitem">
<div class="csl-left-margin">[38] </div><div class="csl-right-inline">P.
B. Warren, S. TÄƒnase-Nicola, and P. R. ten Wolde, <a
href="https://doi.org/10.1063/1.2356472"><span class="nocase">Exact
results for noise power spectra in linear biochemical reaction
networks</span></a>, The Journal of Chemical Physics
<strong>125</strong>, 144904 (2006).</div>
</div>
<div id="ref-2010.Tostevin" class="csl-entry" role="listitem">
<div class="csl-left-margin">[39] </div><div class="csl-right-inline">F.
Tostevin and P. R. ten Wolde, <a
href="https://doi.org/10.1103/PhysRevE.81.061917">Mutual information in
time-varying biochemical systems</a>, Phys. Rev. E <strong>81</strong>,
061917 (2010).</div>
</div>
<div id="ref-2023.Moor" class="csl-entry" role="listitem">
<div class="csl-left-margin">[40] </div><div
class="csl-right-inline">A.-L. Moor and C. Zechner, <a
href="https://doi.org/10.1103/physrevresearch.5.013032"><span
class="nocase">Dynamic information transfer in stochastic biochemical
networks</span></a>, Physical Review Research <strong>5</strong>, 013032
(2023).</div>
</div>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Indeed, the mutual information
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’®</mi><mo>,</mo><mi>ğ’³</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{I}(\mathcal{S}, \mathcal{X})</annotation></semantics></math>
precisely quantifies how strong the statistical dependence is between
the trajectory-valued random variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’®</mi><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’³</mi><annotation encoding="application/x-tex">\mathcal{X}</annotation></semantics></math>.
From its definition
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’®</mi><mo>,</mo><mi>ğ’³</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi mathvariant="normal">H</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’®</mi><mo stretchy="false" form="postfix">)</mo><mo>âˆ’</mo><mi mathvariant="normal">H</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’®</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’³</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{I}(\mathcal{S}, \mathcal{X})=\mathrm{H}(\mathcal{S}) - \mathrm{H}(\mathcal{S}|\mathcal{X})</annotation></semantics></math>
we can understand more clearly how this affects the efficiency of the
Monte Carlo estimate. Roughly speaking,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">H</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’®</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{H}(\mathcal{S})</annotation></semantics></math>
is related to the number of distinct trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
that can arise from the dynamics given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>,
while
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">H</mi><mo stretchy="false" form="prefix">(</mo><mi>ğ’®</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’³</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{H}(\mathcal{S}|\mathcal{X})</annotation></semantics></math>
is related to the number of distinct trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
that could have lead to a specific output
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>,
on average. Therefore, if the mutual information is very large, the
difference between these two numbers is very large, and consequently the
number of overall distinct trajectories is much larger than the number
of distinct trajectories compatible with output
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>.
Now, if we generate trajectories according to the dynamics given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{s}]</annotation></semantics></math>,
with overwhelming probability we generate a trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’”</mi><annotation encoding="application/x-tex">\mathbfit{s}</annotation></semantics></math>
which is not compatible with the output trajectory
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’™</mi><annotation encoding="application/x-tex">\mathbfit{x}</annotation></semantics></math>,
and therefore
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’«</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="prefix">|</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo><mo>â‰ˆ</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathcal{P}[\mathbfit{x}|\mathbfit{s}]\approx 0</annotation></semantics></math>.
Hence, the effective number of samples
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mtext mathvariant="normal">eff</mtext></msub><annotation encoding="application/x-tex">M_\text{eff}</annotation></semantics></math>
is much smaller than the actual number of generated trajectories
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>,
i.e.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mtext mathvariant="normal">eff</mtext></msub><mo>â‰ª</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M_\text{eff} \ll M</annotation></semantics></math>.
We therefore only expect the estimate in <a
href="#eq:marginal-naive">eq:marginal-naive</a> to be reliable when
computing the mutual information for systems where it is not too high.
Thus, strikingly, the difficulty of computing the mutual information is
proportional to the magnitude of the mutual information itself.<a
href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn2"><p>Note that while the distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>exp</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>ğ’°</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo>,</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mi>Z</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’™</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\exp(-\mathcal{U}[\mathbfit{s},\mathbfit{x}])/Z[\mathbfit{x}]</annotation></semantics></math>
resembles the equilibrium distribution of a canonical ensemble from
statistical mechanics, this does not imply that we are studying systems
in thermal equilibrium. Indeed, PWS is used to quantify information
transmission in systems driven out of equilibrium by the input signal.
Thus, the notation introduced in this section is merely a mathematical
reformulation of the marginalization integral to make the analogy to
statistical physics apparent. We assign no physical meaning to the
potentials and free energies. Also note that we set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi mathvariant="normal">B</mi></msub><mi>T</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k_{\mathrm{B}}T = 1</annotation></semantics></math>
since temperature is irrelevant here.<a href="#fnref2"
class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn3"><p>The samples generated through resampling are only
approximate because they are limited to the discrete set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msup><mi>ğ’”</mi><mn>1</mn></msup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msup><mi>ğ’”</mi><mi>M</mi></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathbfit{s}^1, \ldots, \mathbfit{s}^M\}</annotation></semantics></math>,
which was originally drawn from the prior distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">[</mo><mi>ğ’”</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">f[\mathbfit{s}]</annotation></semantics></math>.
The resampling process assigns weights based on the target distribution,
which are used to select from that set, but it does not generate
entirely new samples directly from the target. Therefore, the sampled
points do not constitute draws from the target distribution unless
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>â†’</mo><mi>âˆ</mi></mrow><annotation encoding="application/x-tex">M \rightarrow \infty</annotation></semantics></math>.<a
href="#fnref3" class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn4"><p><a href="https://github.com/zechnerlab/PathMI"
class="uri">https://github.com/zechnerlab/PathMI</a><a href="#fnref4"
class="footnote-back" role="doc-backlink">â†©ï¸</a></p></li>
<li id="fn5"><p>A detailed analysis of this observation was carried out
in a (currently unpublished) collaborative work with Anne-Lena Moor and
Christoph Zechner from the MPI-CBG in Dresden <span class="citation"
data-cites="2024.Moor">Â [<a href="#ref-2024.Moor"
role="doc-biblioref">33</a>]</span>. This work demonstrates that the
discrepancy arises because all the information on the input signal is
contained in the output speciesâ€™ production process, which is catalyzed
by the input, rather than in the decay process of the output, which
occurs independently of the input. The PWS result captures this
distinction by using a fully discrete approach. In contrast, the
Gaussian estimate of the linear-noise approximation misses this
distinction because in the noise term for the output the contributions
from the production and decay reactions are added together. We also
comment further on this matter in <a href="#ch:lna_vs_pws">Ch.
lna_vs_pws</a>.<a href="#fnref5" class="footnote-back"
role="doc-backlink">â†©ï¸</a></p></li>
</ol>
</section>
</body>
</html>
